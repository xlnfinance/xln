# Руководство по разработке XLN Consensus системы

## Обзор проекта
XLN (Cross-chain Liquidity Network) consensus система с византийской отказоустойчивостью для финансовых приложений. Основная функциональность: поток propose→sign→commit с правильной синхронизацией состояния между распределенными валидаторами.

## Основные правила архитектуры

### 1. Управление состоянием
- **Неизменяемость на уровне транзакций**: Каждый `applyEntityTx` создает новые объекты состояния
- **Изменяемость для производительности**: Коллекции (mempool, signatures) используют мутабельные операции внутри обработки
- **Разделение типов состояния**: `EntityState` (данные консенсуса) vs `ServerState` (инфраструктура)
- **Никаких общих ссылок на состояние**: Каждая реплика получает свою копию состояния

### 2. Соглашения по именованию
- **Префиксы по области видимости**: `entityState`, `serverState`, `entityReplica`, `serverTx`
- **Четкие намерения**: `entityOutbox` (не `entityOutputs`), `ProposedEntityFrame` (не `Proposal`)
- **Описательные переменные**: `replicaKey`, `frameSignature`, `validatorId`, `proposerId`
- **Последовательная терминология**: Всегда используйте "entity" для уровня консенсуса, "server" для инфраструктуры

### 3. Дизайн функций
- **Единая ответственность**: `applyEntityTx` обрабатывает одну транзакцию, `applyEntityFrame` обрабатывает пакеты
- **Никаких двойных вычислений**: Предвычисляйте состояние в предложении, переиспользуйте в коммите
- **Четкие интерфейсы**: `ServerInput` разделяет `serverTxs` от `entityInputs`
- **Вспомогательные функции**: `processUntilEmpty` для упрощения итераций

## Критические паттерны багов и исправления

### 1. Баги маршрутизации
**Проблема**: Использование `input.from` вместо `input.to` в маршрутизации сообщений
**Исправление**: Всегда маршрутизируйте сообщения к предназначенным получателям
```typescript
// ❌ Неправильно - маршрутизация к отправителю
signerId: entityReplica.signerId

// ✅ Правильно - маршрутизация к пропоузеру
signerId: proposerId
```

### 2. Фантом консенсуса
**Проблема**: Каждая реплика заявляет о том, что она пропоузер
**Исправление**: Только первый валидатор является пропоузером, остальные - валидаторы
```typescript
isProposer: index === 0  // Только первый валидатор
```

### 3. Синхронизация состояния
**Проблема**: Валидаторы-не-пропоузеры не получают уведомления о коммите
**Исправление**: Сохраняйте данные предложения перед очисткой, уведомляйте всех валидаторов
```typescript
// Сохраняем перед очисткой
const committedSignatures = Array.from(entityReplica.proposal.signatures);
const committedHash = entityReplica.proposal.hash;
entityReplica.proposal = undefined;

// Уведомляем всех валидаторов
entityReplica.state.validators.forEach(validatorId => {
  entityOutbox.push({
    entityId: entityInput.entityId,
    signerId: validatorId,
    precommits: committedSignatures,
    proposedFrame: committedHash
  });
});
```

## Руководство по стилю кода

### 1. Функциональное программирование
- **Никаких классов**: Используйте только интерфейсы и функции
- **Никаких CommonJS**: Всегда используйте ES модули (`import`/`export`)
- **Паттерны неизменяемости**: Создавайте новые объекты вместо мутации существующих
- **Чистые функции**: `applyEntityTx`, `applyEntityFrame` не имеют побочных эффектов

### 2. Предотвращение ошибок
- **Строгая типизация**: Используйте TypeScript интерфейсы для всех структур данных
- **Валидация**: Проверяйте пороги, валидируйте подписи, верифицируйте переходы состояний
- **Защитное программирование**: Проверяйте существование перед обращением (`entityReplica?.`)

### 3. Соображения производительности
- **Изменяемые коллекции**: Используйте `push()`, `set()`, `clear()` для критических по производительности путей
- **Пакетные операции**: Используйте `leveldb batch()` для операций с базой данных
- **Эффективные итерации**: `while (outputs.length > 0)` вместо ручного пошагового выполнения

## Тестирование и отладка

### 1. Паттерн глобального дебага
```typescript
let DEBUG = true;
// Используйте по всему коду без передачи параметров
if (DEBUG) console.log(`→ Детали операции`);
```

### 2. Всестороннее логирование
- **Переходы состояний**: Логируйте изменения высоты, операции с mempool
- **Поток сообщений**: Отслеживайте входы/выходы с подсчетами и типами
- **Прогресс консенсуса**: Показывайте сбор подписей, достижение порога
- **Финальная верификация**: Проверяйте, что все реплики имеют одинаковое состояние

### 3. Верификация тестов
- **Всегда запускайте**: `npm test` перед возвращением результатов
- **Согласованность состояния**: Верифицируйте, что все реплики сходятся к одному состоянию
- **Целостность сообщений**: Проверяйте порядок и содержание транзакций
- **Метрики консенсуса**: Отслеживайте время завершения, количество сообщений

## Паттерны распределенных систем

### 1. Реалистичная архитектура
- **Отдельные серверные транзакции**: Каждый валидатор получает свою транзакцию `importReplica`
- **Маршрутизация транзакций**: Все транзакции идут через пропоузера для консенсуса
- **Координация валидаторов**: Пропоузер рассылает всем валидаторам

### 2. Поток консенсуса
1. **Фаза импорта**: Настройка реплик со списками валидаторов
2. **Фаза предложения**: Пропоузер создает фрейм, рассылает валидаторам
3. **Фаза подписи**: Валидаторы подписывают и отправляют предкоммиты пропоузеру
4. **Фаза коммита**: Пропоузер собирает подписи, рассылает финальное состояние
5. **Фаза применения**: Все реплики применяют зафиксированный фрейм

### 3. Управление состоянием
- **Mempool**: Временное хранилище транзакций перед консенсусом
- **Предложения**: Ожидающие фреймы, ждущие порога подписей
- **Зафиксированное состояние**: Финальное согласованное состояние между всеми репликами

## Рабочий процесс разработки

### 1. Инкрементальные шаги
- Начинайте с минимальной рабочей версии
- Добавляйте по одной функции за раз
- Верифицируйте каждый шаг перед продолжением
- Тщательно тестируйте на каждом этапе

### 2. Эволюция кода
- Начинайте с простых реализаций
- Рефакторьте для ясности и производительности
- Удаляйте избыточный код и состояние
- Оптимизируйте критические пути

### 3. Документация
- Логируйте все значимые операции
- Добавляйте комментарии для сложной логики
- Поддерживайте четкие имена переменных
- Документируйте контракты интерфейсов

## Соображения для финансовых систем

### 1. Надежность
- **Византийская отказоустойчивость**: Обрабатывайте злонамеренных валидаторов
- **Согласованность состояния**: Обеспечивайте согласие всех реплик на финальное состояние
- **Упорядочивание транзакций**: Поддерживайте детерминированную последовательность

### 2. Безопасность
- **Валидация подписей**: Верифицируйте все предкоммиты перед принятием
- **Принуждение к порогу**: Требуйте минимальные подписи для коммитов
- **Валидация состояния**: Проверяйте валидность транзакций перед применением

### 3. Производительность
- **Пакетная обработка**: Группируйте транзакции для эффективности
- **Минимальное копирование состояния**: Копируйте только при необходимости
- **Эффективные структуры данных**: Используйте Maps для O(1) поиска

## Частые ловушки, которых следует избегать

1. **Мутации общего состояния**: Каждая реплика нуждается в независимом состоянии
2. **Ошибки маршрутизации**: Всегда верифицируйте адресатов сообщений
3. **Двойные вычисления**: Предвычисляйте состояние в предложениях
4. **Пропущенные уведомления**: Обеспечивайте получение коммитов всеми валидаторами
5. **Фантомный консенсус**: Только назначенный пропоузер должен предлагать
6. **Несогласованность состояния**: Валидируйте, что все реплики сходятся
7. **Узкие места производительности**: Используйте мутабельные операции для горячих путей
8. **Сложные абстракции**: Предпочитайте простые, ясные реализации

## Метрики успеха
- ✅ Все реплики имеют идентичное финальное состояние
- ✅ Консенсус завершается в разумное время
- ✅ Все транзакции правильно упорядочены
- ✅ Тесты проходят стабильно
- ✅ Код чист и сопровождаем
- ✅ Отладочный вывод обеспечивает четкую видимость 