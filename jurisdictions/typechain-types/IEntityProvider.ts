/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "./common";

export declare namespace IEntityProvider {
  export type EntityStruct = {
    currentBoardHash: BytesLike;
    proposedBoardHash: BytesLike;
    activateAtBlock: BigNumberish;
    registrationBlock: BigNumberish;
    proposerType: BigNumberish;
    articlesHash: BytesLike;
  };

  export type EntityStructOutput = [
    currentBoardHash: string,
    proposedBoardHash: string,
    activateAtBlock: bigint,
    registrationBlock: bigint,
    proposerType: bigint,
    articlesHash: string
  ] & {
    currentBoardHash: string;
    proposedBoardHash: string;
    activateAtBlock: bigint;
    registrationBlock: bigint;
    proposerType: bigint;
    articlesHash: string;
  };

  export type BoardStruct = {
    votingThreshold: BigNumberish;
    entityIds: BytesLike[];
    votingPowers: BigNumberish[];
    boardChangeDelay: BigNumberish;
    controlChangeDelay: BigNumberish;
    dividendChangeDelay: BigNumberish;
  };

  export type BoardStructOutput = [
    votingThreshold: bigint,
    entityIds: string[],
    votingPowers: bigint[],
    boardChangeDelay: bigint,
    controlChangeDelay: bigint,
    dividendChangeDelay: bigint
  ] & {
    votingThreshold: bigint;
    entityIds: string[];
    votingPowers: bigint[];
    boardChangeDelay: bigint;
    controlChangeDelay: bigint;
    dividendChangeDelay: bigint;
  };

  export type EntityArticlesStruct = {
    controlDelay: BigNumberish;
    dividendDelay: BigNumberish;
    foundationDelay: BigNumberish;
    controlThreshold: BigNumberish;
  };

  export type EntityArticlesStructOutput = [
    controlDelay: bigint,
    dividendDelay: bigint,
    foundationDelay: bigint,
    controlThreshold: bigint
  ] & {
    controlDelay: bigint;
    dividendDelay: bigint;
    foundationDelay: bigint;
    controlThreshold: bigint;
  };
}

export interface IEntityProviderInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "activateBoard"
      | "getEntity"
      | "proposeNewBoard"
      | "recoverEntity"
      | "registerEntity"
      | "verifyHankoSignature"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "BoardActivated"
      | "BoardProposed"
      | "EntityRegistered"
      | "HankoVerified"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "activateBoard",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getEntity",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "proposeNewBoard",
    values: [
      BytesLike,
      IEntityProvider.BoardStruct,
      IEntityProvider.EntityArticlesStruct,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "recoverEntity",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "registerEntity",
    values: [IEntityProvider.BoardStruct, IEntityProvider.EntityArticlesStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "verifyHankoSignature",
    values: [BytesLike, BytesLike]
  ): string;

  decodeFunctionResult(
    functionFragment: "activateBoard",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getEntity", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proposeNewBoard",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "recoverEntity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerEntity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "verifyHankoSignature",
    data: BytesLike
  ): Result;
}

export namespace BoardActivatedEvent {
  export type InputTuple = [entityId: BytesLike, newBoardHash: BytesLike];
  export type OutputTuple = [entityId: string, newBoardHash: string];
  export interface OutputObject {
    entityId: string;
    newBoardHash: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace BoardProposedEvent {
  export type InputTuple = [entityId: BytesLike, proposedBoardHash: BytesLike];
  export type OutputTuple = [entityId: string, proposedBoardHash: string];
  export interface OutputObject {
    entityId: string;
    proposedBoardHash: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace EntityRegisteredEvent {
  export type InputTuple = [
    entityId: BytesLike,
    entityNumber: BigNumberish,
    boardHash: BytesLike
  ];
  export type OutputTuple = [
    entityId: string,
    entityNumber: bigint,
    boardHash: string
  ];
  export interface OutputObject {
    entityId: string;
    entityNumber: bigint;
    boardHash: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace HankoVerifiedEvent {
  export type InputTuple = [entityId: BytesLike, hash: BytesLike];
  export type OutputTuple = [entityId: string, hash: string];
  export interface OutputObject {
    entityId: string;
    hash: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface IEntityProvider extends BaseContract {
  connect(runner?: ContractRunner | null): IEntityProvider;
  waitForDeployment(): Promise<this>;

  interface: IEntityProviderInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  activateBoard: TypedContractMethod<
    [entityId: BytesLike],
    [void],
    "nonpayable"
  >;

  getEntity: TypedContractMethod<
    [entityId: BytesLike],
    [IEntityProvider.EntityStructOutput],
    "view"
  >;

  proposeNewBoard: TypedContractMethod<
    [
      entityId: BytesLike,
      newBoard: IEntityProvider.BoardStruct,
      articles: IEntityProvider.EntityArticlesStruct,
      proposerType: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  recoverEntity: TypedContractMethod<
    [encodedBoard: BytesLike, encodedSignature: BytesLike, hash: BytesLike],
    [bigint],
    "view"
  >;

  registerEntity: TypedContractMethod<
    [
      board: IEntityProvider.BoardStruct,
      articles: IEntityProvider.EntityArticlesStruct
    ],
    [string],
    "nonpayable"
  >;

  verifyHankoSignature: TypedContractMethod<
    [hankoData: BytesLike, hash: BytesLike],
    [[string, boolean]],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "activateBoard"
  ): TypedContractMethod<[entityId: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "getEntity"
  ): TypedContractMethod<
    [entityId: BytesLike],
    [IEntityProvider.EntityStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "proposeNewBoard"
  ): TypedContractMethod<
    [
      entityId: BytesLike,
      newBoard: IEntityProvider.BoardStruct,
      articles: IEntityProvider.EntityArticlesStruct,
      proposerType: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "recoverEntity"
  ): TypedContractMethod<
    [encodedBoard: BytesLike, encodedSignature: BytesLike, hash: BytesLike],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "registerEntity"
  ): TypedContractMethod<
    [
      board: IEntityProvider.BoardStruct,
      articles: IEntityProvider.EntityArticlesStruct
    ],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "verifyHankoSignature"
  ): TypedContractMethod<
    [hankoData: BytesLike, hash: BytesLike],
    [[string, boolean]],
    "nonpayable"
  >;

  getEvent(
    key: "BoardActivated"
  ): TypedContractEvent<
    BoardActivatedEvent.InputTuple,
    BoardActivatedEvent.OutputTuple,
    BoardActivatedEvent.OutputObject
  >;
  getEvent(
    key: "BoardProposed"
  ): TypedContractEvent<
    BoardProposedEvent.InputTuple,
    BoardProposedEvent.OutputTuple,
    BoardProposedEvent.OutputObject
  >;
  getEvent(
    key: "EntityRegistered"
  ): TypedContractEvent<
    EntityRegisteredEvent.InputTuple,
    EntityRegisteredEvent.OutputTuple,
    EntityRegisteredEvent.OutputObject
  >;
  getEvent(
    key: "HankoVerified"
  ): TypedContractEvent<
    HankoVerifiedEvent.InputTuple,
    HankoVerifiedEvent.OutputTuple,
    HankoVerifiedEvent.OutputObject
  >;

  filters: {
    "BoardActivated(bytes32,bytes32)": TypedContractEvent<
      BoardActivatedEvent.InputTuple,
      BoardActivatedEvent.OutputTuple,
      BoardActivatedEvent.OutputObject
    >;
    BoardActivated: TypedContractEvent<
      BoardActivatedEvent.InputTuple,
      BoardActivatedEvent.OutputTuple,
      BoardActivatedEvent.OutputObject
    >;

    "BoardProposed(bytes32,bytes32)": TypedContractEvent<
      BoardProposedEvent.InputTuple,
      BoardProposedEvent.OutputTuple,
      BoardProposedEvent.OutputObject
    >;
    BoardProposed: TypedContractEvent<
      BoardProposedEvent.InputTuple,
      BoardProposedEvent.OutputTuple,
      BoardProposedEvent.OutputObject
    >;

    "EntityRegistered(bytes32,uint256,bytes32)": TypedContractEvent<
      EntityRegisteredEvent.InputTuple,
      EntityRegisteredEvent.OutputTuple,
      EntityRegisteredEvent.OutputObject
    >;
    EntityRegistered: TypedContractEvent<
      EntityRegisteredEvent.InputTuple,
      EntityRegisteredEvent.OutputTuple,
      EntityRegisteredEvent.OutputObject
    >;

    "HankoVerified(bytes32,bytes32)": TypedContractEvent<
      HankoVerifiedEvent.InputTuple,
      HankoVerifiedEvent.OutputTuple,
      HankoVerifiedEvent.OutputObject
    >;
    HankoVerified: TypedContractEvent<
      HankoVerifiedEvent.InputTuple,
      HankoVerifiedEvent.OutputTuple,
      HankoVerifiedEvent.OutputObject
    >;
  };
}
