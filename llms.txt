# xln - Complete Technical Context

> Cross-jurisdictional off-chain settlement network with Byzantine Fault Tolerant consensus

**URL**: https://xln.finance
**Status**: Pre-testnet (Q1 2026)
**Repository**: https://github.com/xlnfinance/xln (public), https://github.com/xlnfinance/_xln (private)
**Author**: Egor Homakov (Sakurity)

---

## THE CORE INNOVATION: RCPAN Invariant

XLN solves what was thought impossible: **instant settlement without blockchain latency**.

The breakthrough is the RCPAN invariant that unifies credit and collateral:

```
−Lₗ ≤ Δ ≤ C + Lᵣ
```

**Where:**
- **Δ** = net balance (positive = you owe me, negative = I owe you)
- **C** = my collateral (what I can lose)
- **Lₗ** = credit I extend to you (unsecured lending)
- **Lᵣ** = credit you extend to me (your trust in me)

**This single invariant:**
- Eliminates FCUAN problem (Fractional Collateral Under Arbitrary Netting)
- Eliminates FRPAP problem (Full Reserve Precludes Arbitrary Payments)
- Enables instant bilateral netting with partial collateral
- Makes credit programmable and composable

---

## Competitive Landscape

| System | Settlement | Collateral | Credit | Netting | Trust Model |
|--------|-----------|------------|---------|---------|-------------|
| **XLN** | Instant (bilateral) | Partial (RCPAN) | Programmable | Yes (bilateral) | BFT consensus |
| Lightning | Near-instant | Full (100%) | No | No | Unilateral exit |
| Rollups | 7-day finality | Full (100%) | No | No (batch only) | Fraud proof |
| Banks | T+2 settlement | Fractional (~10%) | Yes | Yes (multilateral) | Legal system |
| Ripple/Stellar | 3-5 sec | Trust lines | Trust lines | Limited | Consensus |

**XLN uniquely combines**: Bank-like netting + Lightning-like instant settlement + Programmable credit

---

## Impossible Before XLN

1. **Instant cross-chain atomic swaps with <100% collateral** - Lightning requires full collateral, XLN uses RCPAN
2. **Bilateral settlement without fraud period** - Rollups need 7 days, XLN settles instantly via consensus
3. **Programmable credit as first-class primitive** - Banks have credit but not programmable, crypto has programs but not credit
4. **Multi-hop payments that NET positions** - Ripple batches, Lightning routes, only XLN nets bilaterally
5. **Entity-owned subcontracts (HTLCs, limit orders) without separate channels** - One bilateral account, many subcontracts

---

## Three-Layer Architecture (JEA Model)

**J → Jurisdiction (L1 blockchain)**
- Smart contracts: `Depository.sol`, `EntityProvider.sol`
- Manages reserves, enforces debts via `enforceDebts()` FIFO queue
- On-chain finality for disputes

**E → Entity (BFT consensus node)**
- State machine: ADD_TX → PROPOSE → SIGN → COMMIT
- Threshold signatures (BLS aggregation)
- Maintains bilateral accounts with other entities

**A → Account (bilateral state machine)**
- Pure delta tracking between two entities
- RCPAN invariant enforced locally
- Subcontracts (HTLCs, limit orders) run here

**Flow**: Runtime (100ms ticks) → Entity consensus → Account updates

---

## Key Data Structures

**EntityFrame** (entity-level consensus):
```typescript
{
  height: bigint,              // Monotonic frame number
  timestamp: bigint,           // Unix milliseconds
  prevHash: Uint8Array,        // Keccak256 of previous frame
  transactions: Transaction[], // Sorted by nonce → from → kind
  stateRoot: Uint8Array,       // Merkle root of all account states
  signatures: {[entityId: string]: Uint8Array}  // BLS threshold sigs
}
```

**AccountFrame** (bilateral consensus):
```typescript
{
  height: bigint,
  deltas: {[assetId: string]: bigint}, // Net balances
  collateral: bigint,                   // My locked reserves
  creditLimits: {left: bigint, right: bigint},
  stateHash: Uint8Array,               // Keccak256(deltas+collateral+limits)
  leftSignature: Uint8Array,
  rightSignature: Uint8Array
}
```

**Transaction Types**:
- `SetCreditLimit`: Extend credit to counterparty
- `AddDelta`: Propose balance change (payment, HTLC, etc.)
- `SettleSubcontract`: Resolve conditional payment
- `Dispute`: Challenge invalid state on-chain

---

## Consensus Protocol

**Entity Layer (BFT)**:
1. Leader proposes EntityFrame with sorted transactions
2. Validators verify: signatures valid, nonces sequential, state transitions correct
3. Threshold (2/3+) sign → COMMIT
4. Frame hash = Keccak256(height || timestamp || prevHash || stateRoot)

**Account Layer (Bilateral)**:
1. Entity A proposes AccountFrame with new deltas
2. Entity B verifies: RCPAN invariant holds, state hash matches
3. Both sign → bilateral consensus achieved
4. If dispute: submit signed frames to Depository.sol on-chain

**Deterministic Replay**:
- All timestamps are bigint unix-ms
- Transactions sorted: nonce → from → kind → insertion-index
- RLP encoding for canonical binary representation
- Keccak-256 hashing ensures reproducibility

---

## Building on XLN: Delta Transformers

Every bilateral account is a **programmable state machine**. Examples:

**HTLC (Hash Time-Locked Contract)**:
```typescript
// Alice → Bob payment locked by hash H
Δ_proposed = +1000  // Bob gets +1000 IF he reveals R where hash(R) = H
// If Bob reveals R before timeout: commit Δ_proposed
// If timeout expires: revert Δ_proposed
```

**Limit Order**:
```typescript
// "Buy 100 USDC at 0.5 ETH each when ETH/USDC ≤ 2000"
if (oraclePrice <= 2000) {
  Δ_USDC = +100
  Δ_ETH = -50
}
```

**Multi-hop Netting**:
```typescript
// Instead of A→B→C→D, net directly to A→D
multiHopDeltas = [{A: -100}, {B: +100, C: -100}, {D: +100}]
nettedDelta = {A: -100, D: +100}  // B and C cancel out
```

---

## Smart Contracts (Solidity)

**Depository.sol** - Reserve management:
```solidity
// FIFO debt enforcement
function enforceDebts(address[] memory debtors) {
  for (uint i = 0; i < debtors.length; i++) {
    uint debt = debts[debtors[i]];
    uint seized = min(debt, deposits[debtors[i]]);
    deposits[debtors[i]] -= seized;
    debts[debtors[i]] -= seized;
  }
}

// RCPAN verification on-chain
function verifyInvariant(int delta, uint collateral, uint leftCredit, uint rightCredit) {
  require(delta >= -int(leftCredit), "Left credit exceeded");
  require(delta <= int(collateral + rightCredit), "Right collateral+credit exceeded");
}
```

**EntityProvider.sol** - Entity registration:
```solidity
function registerEntity(
  address[] memory validators,
  uint threshold
) returns (bytes32 entityId) {
  require(threshold >= (validators.length * 2) / 3 + 1, "BFT threshold");
  entityId = keccak256(abi.encodePacked(validators, threshold));
  entities[entityId] = Entity({validators, threshold, active: true});
}
```

---

---

## Implementation Files (GitHub)

**Core Runtime** (TypeScript):
- `runtime/runtime.ts` - Main 100ms tick coordinator, R→E→A flow
- `runtime/entity-consensus.ts` - Entity-level BFT (ADD_TX → PROPOSE → SIGN → COMMIT)
- `runtime/account-consensus.ts` - Bilateral consensus between entity pairs
- `runtime/types.ts` - All TypeScript interfaces (EntityFrame, AccountFrame, Transaction)
- `runtime/evm.ts` - Blockchain integration (loads Depository.sol, EntityProvider.sol)

**Smart Contracts** (Solidity):
- `jurisdictions/contracts/Depository.sol` - Reserve management, enforceDebts() FIFO
- `jurisdictions/contracts/EntityProvider.sol` - Entity registration, BFT quorum verification

**Frontend** (SvelteKit):
- `frontend/src/routes/+page.svelte` - Visual debugging UI with time machine
- `frontend/src/lib/view/` - 3D network visualization (Three.js)

---

## Example Scenarios

**simnet-grid.scenario.txt** - 3×3 grid topology:
```
E1 ←→ E2 ←→ E3
↕     ↕     ↕
E4 ←→ E5 ←→ E6
↕     ↕     ↕
E7 ←→ E8 ←→ E9
```

**diamond-dybvig.scenario.txt** - Bank run simulation:
- Entity acts as bank with 10:1 fractional reserve
- Depositors simultaneously withdraw → tests RCPAN limits
- Demonstrates bounded risk (loss capped at collateral)

---

## Further Reading (Links)

**If you want the FULL 112k token context**, read:
- https://xln.finance/c.txt - Complete technical specification (all contracts + runtime + architecture)

**If you want to build on xln**, read:
- https://github.com/xlnfinance/xln/tree/main/vibepaper/docs - Q&A, comparisons, protocol specs
- https://github.com/xlnfinance/xln/blob/main/CLAUDE.md - Development guidelines

**If you want to understand philosophy**, read:
- https://github.com/xlnfinance/xln/blob/main/vibepaper/readme.md - Architecture overview

---

## Technical Stack

- **Runtime**: Bun + TypeScript (browser-targeted build)
- **Frontend**: SvelteKit + Three.js (3D visualization, time machine debugging)
- **Contracts**: Solidity + Hardhat (Depository.sol, EntityProvider.sol)
- **Consensus**: Pure functional state machines with deterministic replay
- **Cryptography**: secp256k1 (addresses), Keccak-256 (hashing), BLS (threshold signatures)

---

## Philosophy

Byzantine Fault Tolerant off-chain settlement with deterministic replay and instant finality. Pure functional state machines with side effects only in runtime shell. Credit and collateral unified via RCPAN invariant for predictable economic behavior.

**Key principles:**
- Unicast (1-to-1) beats broadcast at planetary scale
- Every phone/laptop will be a full node by default
- Banking 2.0 with zero new terminology invented

---

## Contact

**Author**: Egor Homakov (Sakurity)
**Website**: https://xln.finance
**Twitter**: https://twitter.com/xln_finance
**Telegram**: https://t.me/xlnomist
**Email**: h@xln.finance
**GitHub**: https://github.com/xlnfinance/xln
**Testnet Launch**: Q1 2026
