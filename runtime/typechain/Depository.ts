/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../common";

export type SettledStruct = {
  left: BytesLike;
  right: BytesLike;
  tokenId: BigNumberish;
  leftReserve: BigNumberish;
  rightReserve: BigNumberish;
  collateral: BigNumberish;
  ondelta: BigNumberish;
};

export type SettledStructOutput = [
  left: string,
  right: string,
  tokenId: bigint,
  leftReserve: bigint,
  rightReserve: bigint,
  collateral: bigint,
  ondelta: bigint
] & {
  left: string;
  right: string;
  tokenId: bigint;
  leftReserve: bigint;
  rightReserve: bigint;
  collateral: bigint;
  ondelta: bigint;
};

export type SettlementDiffStruct = {
  tokenId: BigNumberish;
  leftDiff: BigNumberish;
  rightDiff: BigNumberish;
  collateralDiff: BigNumberish;
  ondeltaDiff: BigNumberish;
};

export type SettlementDiffStructOutput = [
  tokenId: bigint,
  leftDiff: bigint,
  rightDiff: bigint,
  collateralDiff: bigint,
  ondeltaDiff: bigint
] & {
  tokenId: bigint;
  leftDiff: bigint;
  rightDiff: bigint;
  collateralDiff: bigint;
  ondeltaDiff: bigint;
};

export type InsuranceRegistrationStruct = {
  insured: BytesLike;
  insurer: BytesLike;
  tokenId: BigNumberish;
  limit: BigNumberish;
  expiresAt: BigNumberish;
};

export type InsuranceRegistrationStructOutput = [
  insured: string,
  insurer: string,
  tokenId: bigint,
  limit: bigint,
  expiresAt: bigint
] & {
  insured: string;
  insurer: string;
  tokenId: bigint;
  limit: bigint;
  expiresAt: bigint;
};

export type AllowanceStruct = {
  deltaIndex: BigNumberish;
  rightAllowance: BigNumberish;
  leftAllowance: BigNumberish;
};

export type AllowanceStructOutput = [
  deltaIndex: bigint,
  rightAllowance: bigint,
  leftAllowance: bigint
] & { deltaIndex: bigint; rightAllowance: bigint; leftAllowance: bigint };

export type TransformerClauseStruct = {
  transformerAddress: AddressLike;
  encodedBatch: BytesLike;
  allowances: AllowanceStruct[];
};

export type TransformerClauseStructOutput = [
  transformerAddress: string,
  encodedBatch: string,
  allowances: AllowanceStructOutput[]
] & {
  transformerAddress: string;
  encodedBatch: string;
  allowances: AllowanceStructOutput[];
};

export type ProofBodyStruct = {
  offdeltas: BigNumberish[];
  tokenIds: BigNumberish[];
  transformers: TransformerClauseStruct[];
};

export type ProofBodyStructOutput = [
  offdeltas: bigint[],
  tokenIds: bigint[],
  transformers: TransformerClauseStructOutput[]
] & {
  offdeltas: bigint[];
  tokenIds: bigint[];
  transformers: TransformerClauseStructOutput[];
};

export type FinalDisputeProofStruct = {
  counterentity: BytesLike;
  initialCooperativeNonce: BigNumberish;
  finalCooperativeNonce: BigNumberish;
  initialDisputeNonce: BigNumberish;
  finalDisputeNonce: BigNumberish;
  initialProofbodyHash: BytesLike;
  finalProofbody: ProofBodyStruct;
  finalArguments: BytesLike;
  initialArguments: BytesLike;
  sig: BytesLike;
  startedByLeft: boolean;
  disputeUntilBlock: BigNumberish;
  cooperative: boolean;
};

export type FinalDisputeProofStructOutput = [
  counterentity: string,
  initialCooperativeNonce: bigint,
  finalCooperativeNonce: bigint,
  initialDisputeNonce: bigint,
  finalDisputeNonce: bigint,
  initialProofbodyHash: string,
  finalProofbody: ProofBodyStructOutput,
  finalArguments: string,
  initialArguments: string,
  sig: string,
  startedByLeft: boolean,
  disputeUntilBlock: bigint,
  cooperative: boolean
] & {
  counterentity: string;
  initialCooperativeNonce: bigint;
  finalCooperativeNonce: bigint;
  initialDisputeNonce: bigint;
  finalDisputeNonce: bigint;
  initialProofbodyHash: string;
  finalProofbody: ProofBodyStructOutput;
  finalArguments: string;
  initialArguments: string;
  sig: string;
  startedByLeft: boolean;
  disputeUntilBlock: bigint;
  cooperative: boolean;
};

export type InitialDisputeProofStruct = {
  counterentity: BytesLike;
  cooperativeNonce: BigNumberish;
  disputeNonce: BigNumberish;
  proofbodyHash: BytesLike;
  sig: BytesLike;
  initialArguments: BytesLike;
};

export type InitialDisputeProofStructOutput = [
  counterentity: string,
  cooperativeNonce: bigint,
  disputeNonce: bigint,
  proofbodyHash: string,
  sig: string,
  initialArguments: string
] & {
  counterentity: string;
  cooperativeNonce: bigint;
  disputeNonce: bigint;
  proofbodyHash: string;
  sig: string;
  initialArguments: string;
};

export type ExternalTokenToReserveStruct = {
  entity: BytesLike;
  contractAddress: AddressLike;
  externalTokenId: BigNumberish;
  tokenType: BigNumberish;
  internalTokenId: BigNumberish;
  amount: BigNumberish;
};

export type ExternalTokenToReserveStructOutput = [
  entity: string,
  contractAddress: string,
  externalTokenId: bigint,
  tokenType: bigint,
  internalTokenId: bigint,
  amount: bigint
] & {
  entity: string;
  contractAddress: string;
  externalTokenId: bigint;
  tokenType: bigint;
  internalTokenId: bigint;
  amount: bigint;
};

export type FlashloanStruct = { tokenId: BigNumberish; amount: BigNumberish };

export type FlashloanStructOutput = [tokenId: bigint, amount: bigint] & {
  tokenId: bigint;
  amount: bigint;
};

export type ReserveToReserveStruct = {
  receivingEntity: BytesLike;
  tokenId: BigNumberish;
  amount: BigNumberish;
};

export type ReserveToReserveStructOutput = [
  receivingEntity: string,
  tokenId: bigint,
  amount: bigint
] & { receivingEntity: string; tokenId: bigint; amount: bigint };

export type EntityAmountStruct = { entity: BytesLike; amount: BigNumberish };

export type EntityAmountStructOutput = [entity: string, amount: bigint] & {
  entity: string;
  amount: bigint;
};

export type ReserveToCollateralStruct = {
  tokenId: BigNumberish;
  receivingEntity: BytesLike;
  pairs: EntityAmountStruct[];
};

export type ReserveToCollateralStructOutput = [
  tokenId: bigint,
  receivingEntity: string,
  pairs: EntityAmountStructOutput[]
] & {
  tokenId: bigint;
  receivingEntity: string;
  pairs: EntityAmountStructOutput[];
};

export type CollateralToReserveStruct = {
  counterparty: BytesLike;
  tokenId: BigNumberish;
  amount: BigNumberish;
  sig: BytesLike;
};

export type CollateralToReserveStructOutput = [
  counterparty: string,
  tokenId: bigint,
  amount: bigint,
  sig: string
] & { counterparty: string; tokenId: bigint; amount: bigint; sig: string };

export type SettlementStruct = {
  leftEntity: BytesLike;
  rightEntity: BytesLike;
  diffs: SettlementDiffStruct[];
  forgiveDebtsInTokenIds: BigNumberish[];
  insuranceRegs: InsuranceRegistrationStruct[];
  sig: BytesLike;
  entityProvider: AddressLike;
  hankoData: BytesLike;
  nonce: BigNumberish;
};

export type SettlementStructOutput = [
  leftEntity: string,
  rightEntity: string,
  diffs: SettlementDiffStructOutput[],
  forgiveDebtsInTokenIds: bigint[],
  insuranceRegs: InsuranceRegistrationStructOutput[],
  sig: string,
  entityProvider: string,
  hankoData: string,
  nonce: bigint
] & {
  leftEntity: string;
  rightEntity: string;
  diffs: SettlementDiffStructOutput[];
  forgiveDebtsInTokenIds: bigint[];
  insuranceRegs: InsuranceRegistrationStructOutput[];
  sig: string;
  entityProvider: string;
  hankoData: string;
  nonce: bigint;
};

export type ReserveToExternalTokenStruct = {
  receivingEntity: BytesLike;
  tokenId: BigNumberish;
  amount: BigNumberish;
};

export type ReserveToExternalTokenStructOutput = [
  receivingEntity: string,
  tokenId: bigint,
  amount: bigint
] & { receivingEntity: string; tokenId: bigint; amount: bigint };

export type SecretRevealStruct = {
  transformer: AddressLike;
  secret: BytesLike;
};

export type SecretRevealStructOutput = [transformer: string, secret: string] & {
  transformer: string;
  secret: string;
};

export type BatchStruct = {
  flashloans: FlashloanStruct[];
  reserveToReserve: ReserveToReserveStruct[];
  reserveToCollateral: ReserveToCollateralStruct[];
  collateralToReserve: CollateralToReserveStruct[];
  settlements: SettlementStruct[];
  disputeStarts: InitialDisputeProofStruct[];
  disputeFinalizations: FinalDisputeProofStruct[];
  externalTokenToReserve: ExternalTokenToReserveStruct[];
  reserveToExternalToken: ReserveToExternalTokenStruct[];
  revealSecrets: SecretRevealStruct[];
  hub_id: BigNumberish;
};

export type BatchStructOutput = [
  flashloans: FlashloanStructOutput[],
  reserveToReserve: ReserveToReserveStructOutput[],
  reserveToCollateral: ReserveToCollateralStructOutput[],
  collateralToReserve: CollateralToReserveStructOutput[],
  settlements: SettlementStructOutput[],
  disputeStarts: InitialDisputeProofStructOutput[],
  disputeFinalizations: FinalDisputeProofStructOutput[],
  externalTokenToReserve: ExternalTokenToReserveStructOutput[],
  reserveToExternalToken: ReserveToExternalTokenStructOutput[],
  revealSecrets: SecretRevealStructOutput[],
  hub_id: bigint
] & {
  flashloans: FlashloanStructOutput[];
  reserveToReserve: ReserveToReserveStructOutput[];
  reserveToCollateral: ReserveToCollateralStructOutput[];
  collateralToReserve: CollateralToReserveStructOutput[];
  settlements: SettlementStructOutput[];
  disputeStarts: InitialDisputeProofStructOutput[];
  disputeFinalizations: FinalDisputeProofStructOutput[];
  externalTokenToReserve: ExternalTokenToReserveStructOutput[];
  reserveToExternalToken: ReserveToExternalTokenStructOutput[];
  revealSecrets: SecretRevealStructOutput[];
  hub_id: bigint;
};

export interface DepositoryInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "DOMAIN_SEPARATOR"
      | "_accounts"
      | "_activeDebts"
      | "_collaterals"
      | "_debtIndex"
      | "_debts"
      | "_reserves"
      | "_tokens"
      | "accountKey"
      | "addEntityProvider"
      | "admin"
      | "approvedEntityProviders"
      | "computeSettlementHash"
      | "defaultDisputeDelay"
      | "disputeFinalize"
      | "disputeStart"
      | "emergencyPause"
      | "enforceDebts"
      | "enforceDebtsLarge"
      | "entityDisputeDelays"
      | "entityNonces"
      | "entityProvider"
      | "entityProvidersList"
      | "externalTokenToReserve"
      | "getApprovedProviders"
      | "getTokenMetadata"
      | "getTokensLength"
      | "insuranceCursor"
      | "insuranceLines"
      | "mintToReserve"
      | "onERC1155BatchReceived"
      | "onERC1155Received"
      | "packTokenReference"
      | "processBatch"
      | "removeEntityProvider"
      | "reserveToReserve"
      | "setDefaultDisputeDelay"
      | "setEmergencyPause"
      | "setEntityDisputeDelay"
      | "settle"
      | "tokenToId"
      | "unpackTokenReference"
      | "unsafeProcessBatch"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "AccountSettled"
      | "CooperativeClose"
      | "DebtCreated"
      | "DebtEnforced"
      | "DebtForgiven"
      | "DebugSettleStart"
      | "DisputeFinalized"
      | "DisputeStarted"
      | "EmergencyPauseToggled"
      | "EntityProviderAdded"
      | "EntityProviderRemoved"
      | "HankoBatchProcessed"
      | "InsuranceClaimed"
      | "InsuranceRegistered"
      | "ReserveUpdated"
      | "SecretRevealed"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "DOMAIN_SEPARATOR",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_accounts",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "_activeDebts",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "_collaterals",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "_debtIndex",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "_debts",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "_reserves",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "_tokens",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "accountKey",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "addEntityProvider",
    values: [AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "admin", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "approvedEntityProviders",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "computeSettlementHash",
    values: [
      BytesLike,
      BytesLike,
      SettlementDiffStruct[],
      BigNumberish[],
      InsuranceRegistrationStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "defaultDisputeDelay",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "disputeFinalize",
    values: [FinalDisputeProofStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "disputeStart",
    values: [InitialDisputeProofStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "emergencyPause",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "enforceDebts",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "enforceDebtsLarge",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "entityDisputeDelays",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "entityNonces",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "entityProvider",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "entityProvidersList",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "externalTokenToReserve",
    values: [ExternalTokenToReserveStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getApprovedProviders",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenMetadata",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokensLength",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "insuranceCursor",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "insuranceLines",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "mintToReserve",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC1155BatchReceived",
    values: [
      AddressLike,
      AddressLike,
      BigNumberish[],
      BigNumberish[],
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC1155Received",
    values: [AddressLike, AddressLike, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "packTokenReference",
    values: [BigNumberish, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "processBatch",
    values: [BytesLike, AddressLike, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "removeEntityProvider",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "reserveToReserve",
    values: [BytesLike, BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setDefaultDisputeDelay",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setEmergencyPause",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setEntityDisputeDelay",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "settle",
    values: [
      BytesLike,
      BytesLike,
      SettlementDiffStruct[],
      BigNumberish[],
      InsuranceRegistrationStruct[],
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenToId",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "unpackTokenReference",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "unsafeProcessBatch",
    values: [BytesLike, BatchStruct]
  ): string;

  decodeFunctionResult(
    functionFragment: "DOMAIN_SEPARATOR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "_accounts", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "_activeDebts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_collaterals",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "_debtIndex", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "_debts", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "_reserves", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "_tokens", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "accountKey", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "addEntityProvider",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "admin", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "approvedEntityProviders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "computeSettlementHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "defaultDisputeDelay",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "disputeFinalize",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "disputeStart",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "emergencyPause",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enforceDebts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enforceDebtsLarge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "entityDisputeDelays",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "entityNonces",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "entityProvider",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "entityProvidersList",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "externalTokenToReserve",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getApprovedProviders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenMetadata",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokensLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "insuranceCursor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "insuranceLines",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mintToReserve",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155BatchReceived",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155Received",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "packTokenReference",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "processBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeEntityProvider",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "reserveToReserve",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setDefaultDisputeDelay",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setEmergencyPause",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setEntityDisputeDelay",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "settle", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "tokenToId", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "unpackTokenReference",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unsafeProcessBatch",
    data: BytesLike
  ): Result;
}

export namespace AccountSettledEvent {
  export type InputTuple = [settled: SettledStruct[]];
  export type OutputTuple = [settled: SettledStructOutput[]];
  export interface OutputObject {
    settled: SettledStructOutput[];
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace CooperativeCloseEvent {
  export type InputTuple = [
    sender: BytesLike,
    counterentity: BytesLike,
    cooperativeNonce: BigNumberish
  ];
  export type OutputTuple = [
    sender: string,
    counterentity: string,
    cooperativeNonce: bigint
  ];
  export interface OutputObject {
    sender: string;
    counterentity: string;
    cooperativeNonce: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DebtCreatedEvent {
  export type InputTuple = [
    debtor: BytesLike,
    creditor: BytesLike,
    tokenId: BigNumberish,
    amount: BigNumberish,
    debtIndex: BigNumberish
  ];
  export type OutputTuple = [
    debtor: string,
    creditor: string,
    tokenId: bigint,
    amount: bigint,
    debtIndex: bigint
  ];
  export interface OutputObject {
    debtor: string;
    creditor: string;
    tokenId: bigint;
    amount: bigint;
    debtIndex: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DebtEnforcedEvent {
  export type InputTuple = [
    debtor: BytesLike,
    creditor: BytesLike,
    tokenId: BigNumberish,
    amountPaid: BigNumberish,
    remainingAmount: BigNumberish,
    newDebtIndex: BigNumberish
  ];
  export type OutputTuple = [
    debtor: string,
    creditor: string,
    tokenId: bigint,
    amountPaid: bigint,
    remainingAmount: bigint,
    newDebtIndex: bigint
  ];
  export interface OutputObject {
    debtor: string;
    creditor: string;
    tokenId: bigint;
    amountPaid: bigint;
    remainingAmount: bigint;
    newDebtIndex: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DebtForgivenEvent {
  export type InputTuple = [
    debtor: BytesLike,
    creditor: BytesLike,
    tokenId: BigNumberish,
    amountForgiven: BigNumberish,
    debtIndex: BigNumberish
  ];
  export type OutputTuple = [
    debtor: string,
    creditor: string,
    tokenId: bigint,
    amountForgiven: bigint,
    debtIndex: bigint
  ];
  export interface OutputObject {
    debtor: string;
    creditor: string;
    tokenId: bigint;
    amountForgiven: bigint;
    debtIndex: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DebugSettleStartEvent {
  export type InputTuple = [
    leftEntity: BytesLike,
    rightEntity: BytesLike,
    sigLen: BigNumberish,
    entityProvider: AddressLike
  ];
  export type OutputTuple = [
    leftEntity: string,
    rightEntity: string,
    sigLen: bigint,
    entityProvider: string
  ];
  export interface OutputObject {
    leftEntity: string;
    rightEntity: string;
    sigLen: bigint;
    entityProvider: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DisputeFinalizedEvent {
  export type InputTuple = [
    sender: BytesLike,
    counterentity: BytesLike,
    initialDisputeNonce: BigNumberish,
    initialProofbodyHash: BytesLike,
    finalProofbodyHash: BytesLike
  ];
  export type OutputTuple = [
    sender: string,
    counterentity: string,
    initialDisputeNonce: bigint,
    initialProofbodyHash: string,
    finalProofbodyHash: string
  ];
  export interface OutputObject {
    sender: string;
    counterentity: string;
    initialDisputeNonce: bigint;
    initialProofbodyHash: string;
    finalProofbodyHash: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DisputeStartedEvent {
  export type InputTuple = [
    sender: BytesLike,
    counterentity: BytesLike,
    disputeNonce: BigNumberish,
    proofbodyHash: BytesLike,
    initialArguments: BytesLike
  ];
  export type OutputTuple = [
    sender: string,
    counterentity: string,
    disputeNonce: bigint,
    proofbodyHash: string,
    initialArguments: string
  ];
  export interface OutputObject {
    sender: string;
    counterentity: string;
    disputeNonce: bigint;
    proofbodyHash: string;
    initialArguments: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace EmergencyPauseToggledEvent {
  export type InputTuple = [isPaused: boolean];
  export type OutputTuple = [isPaused: boolean];
  export interface OutputObject {
    isPaused: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace EntityProviderAddedEvent {
  export type InputTuple = [provider: AddressLike];
  export type OutputTuple = [provider: string];
  export interface OutputObject {
    provider: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace EntityProviderRemovedEvent {
  export type InputTuple = [provider: AddressLike];
  export type OutputTuple = [provider: string];
  export interface OutputObject {
    provider: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace HankoBatchProcessedEvent {
  export type InputTuple = [
    entityId: BytesLike,
    hankoHash: BytesLike,
    nonce: BigNumberish,
    success: boolean
  ];
  export type OutputTuple = [
    entityId: string,
    hankoHash: string,
    nonce: bigint,
    success: boolean
  ];
  export interface OutputObject {
    entityId: string;
    hankoHash: string;
    nonce: bigint;
    success: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace InsuranceClaimedEvent {
  export type InputTuple = [
    insured: BytesLike,
    insurer: BytesLike,
    creditor: BytesLike,
    tokenId: BigNumberish,
    amount: BigNumberish
  ];
  export type OutputTuple = [
    insured: string,
    insurer: string,
    creditor: string,
    tokenId: bigint,
    amount: bigint
  ];
  export interface OutputObject {
    insured: string;
    insurer: string;
    creditor: string;
    tokenId: bigint;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace InsuranceRegisteredEvent {
  export type InputTuple = [
    insured: BytesLike,
    insurer: BytesLike,
    tokenId: BigNumberish,
    limit: BigNumberish,
    expiresAt: BigNumberish
  ];
  export type OutputTuple = [
    insured: string,
    insurer: string,
    tokenId: bigint,
    limit: bigint,
    expiresAt: bigint
  ];
  export interface OutputObject {
    insured: string;
    insurer: string;
    tokenId: bigint;
    limit: bigint;
    expiresAt: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ReserveUpdatedEvent {
  export type InputTuple = [
    entity: BytesLike,
    tokenId: BigNumberish,
    newBalance: BigNumberish
  ];
  export type OutputTuple = [
    entity: string,
    tokenId: bigint,
    newBalance: bigint
  ];
  export interface OutputObject {
    entity: string;
    tokenId: bigint;
    newBalance: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SecretRevealedEvent {
  export type InputTuple = [
    hashlock: BytesLike,
    revealer: BytesLike,
    secret: BytesLike
  ];
  export type OutputTuple = [
    hashlock: string,
    revealer: string,
    secret: string
  ];
  export interface OutputObject {
    hashlock: string;
    revealer: string;
    secret: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface Depository extends BaseContract {
  connect(runner?: ContractRunner | null): Depository;
  waitForDeployment(): Promise<this>;

  interface: DepositoryInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  DOMAIN_SEPARATOR: TypedContractMethod<[], [string], "view">;

  _accounts: TypedContractMethod<
    [arg0: BytesLike],
    [
      [bigint, string, bigint] & {
        cooperativeNonce: bigint;
        disputeHash: string;
        disputeTimeout: bigint;
      }
    ],
    "view"
  >;

  _activeDebts: TypedContractMethod<[arg0: BytesLike], [bigint], "view">;

  _collaterals: TypedContractMethod<
    [arg0: BytesLike, arg1: BigNumberish],
    [[bigint, bigint] & { collateral: bigint; ondelta: bigint }],
    "view"
  >;

  _debtIndex: TypedContractMethod<
    [arg0: BytesLike, arg1: BigNumberish],
    [bigint],
    "view"
  >;

  _debts: TypedContractMethod<
    [arg0: BytesLike, arg1: BigNumberish, arg2: BigNumberish],
    [[string, bigint] & { creditor: string; amount: bigint }],
    "view"
  >;

  _reserves: TypedContractMethod<
    [arg0: BytesLike, arg1: BigNumberish],
    [bigint],
    "view"
  >;

  _tokens: TypedContractMethod<
    [arg0: BigNumberish],
    [
      [string, bigint, bigint] & {
        contractAddress: string;
        externalTokenId: bigint;
        tokenType: bigint;
      }
    ],
    "view"
  >;

  accountKey: TypedContractMethod<
    [e1: BytesLike, e2: BytesLike],
    [string],
    "view"
  >;

  addEntityProvider: TypedContractMethod<
    [provider: AddressLike],
    [void],
    "nonpayable"
  >;

  admin: TypedContractMethod<[], [string], "view">;

  approvedEntityProviders: TypedContractMethod<
    [arg0: AddressLike],
    [boolean],
    "view"
  >;

  computeSettlementHash: TypedContractMethod<
    [
      leftEntity: BytesLike,
      rightEntity: BytesLike,
      diffs: SettlementDiffStruct[],
      forgiveDebtsInTokenIds: BigNumberish[],
      insuranceRegs: InsuranceRegistrationStruct[]
    ],
    [
      [string, bigint, bigint] & {
        hash: string;
        nonce: bigint;
        encodedMsgLength: bigint;
      }
    ],
    "view"
  >;

  defaultDisputeDelay: TypedContractMethod<[], [bigint], "view">;

  disputeFinalize: TypedContractMethod<
    [params: FinalDisputeProofStruct],
    [boolean],
    "nonpayable"
  >;

  disputeStart: TypedContractMethod<
    [params: InitialDisputeProofStruct],
    [boolean],
    "nonpayable"
  >;

  emergencyPause: TypedContractMethod<[], [boolean], "view">;

  enforceDebts: TypedContractMethod<
    [entity: BytesLike, tokenId: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  enforceDebtsLarge: TypedContractMethod<
    [entity: BytesLike, tokenId: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  entityDisputeDelays: TypedContractMethod<[arg0: BytesLike], [bigint], "view">;

  entityNonces: TypedContractMethod<[arg0: AddressLike], [bigint], "view">;

  entityProvider: TypedContractMethod<[], [string], "view">;

  entityProvidersList: TypedContractMethod<
    [arg0: BigNumberish],
    [string],
    "view"
  >;

  externalTokenToReserve: TypedContractMethod<
    [params: ExternalTokenToReserveStruct],
    [void],
    "nonpayable"
  >;

  getApprovedProviders: TypedContractMethod<[], [string[]], "view">;

  getTokenMetadata: TypedContractMethod<
    [tokenId: BigNumberish],
    [
      [string, bigint, bigint] & {
        contractAddress: string;
        externalTokenId: bigint;
        tokenType: bigint;
      }
    ],
    "view"
  >;

  getTokensLength: TypedContractMethod<[], [bigint], "view">;

  insuranceCursor: TypedContractMethod<[arg0: BytesLike], [bigint], "view">;

  insuranceLines: TypedContractMethod<
    [arg0: BytesLike, arg1: BigNumberish],
    [
      [string, bigint, bigint, bigint] & {
        insurer: string;
        tokenId: bigint;
        remaining: bigint;
        expiresAt: bigint;
      }
    ],
    "view"
  >;

  mintToReserve: TypedContractMethod<
    [entity: BytesLike, tokenId: BigNumberish, amount: BigNumberish],
    [void],
    "nonpayable"
  >;

  onERC1155BatchReceived: TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike,
      arg2: BigNumberish[],
      arg3: BigNumberish[],
      arg4: BytesLike
    ],
    [string],
    "view"
  >;

  onERC1155Received: TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike,
      id: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike
    ],
    [string],
    "nonpayable"
  >;

  packTokenReference: TypedContractMethod<
    [
      tokenType: BigNumberish,
      contractAddress: AddressLike,
      externalTokenId: BigNumberish
    ],
    [string],
    "view"
  >;

  processBatch: TypedContractMethod<
    [
      encodedBatch: BytesLike,
      entityProviderAddr: AddressLike,
      hankoData: BytesLike,
      nonce: BigNumberish
    ],
    [boolean],
    "nonpayable"
  >;

  removeEntityProvider: TypedContractMethod<
    [provider: AddressLike],
    [void],
    "nonpayable"
  >;

  reserveToReserve: TypedContractMethod<
    [
      fromEntity: BytesLike,
      toEntity: BytesLike,
      tokenId: BigNumberish,
      amount: BigNumberish
    ],
    [boolean],
    "nonpayable"
  >;

  setDefaultDisputeDelay: TypedContractMethod<
    [delayBlocks: BigNumberish],
    [void],
    "nonpayable"
  >;

  setEmergencyPause: TypedContractMethod<
    [isPaused: boolean],
    [void],
    "nonpayable"
  >;

  setEntityDisputeDelay: TypedContractMethod<
    [entity: BytesLike, delayBlocks: BigNumberish],
    [void],
    "nonpayable"
  >;

  settle: TypedContractMethod<
    [
      leftEntity: BytesLike,
      rightEntity: BytesLike,
      diffs: SettlementDiffStruct[],
      forgiveDebtsInTokenIds: BigNumberish[],
      insuranceRegs: InsuranceRegistrationStruct[],
      sig: BytesLike
    ],
    [boolean],
    "nonpayable"
  >;

  tokenToId: TypedContractMethod<[arg0: BytesLike], [bigint], "view">;

  unpackTokenReference: TypedContractMethod<
    [packed: BytesLike],
    [
      [string, bigint, bigint] & {
        contractAddress: string;
        externalTokenId: bigint;
        tokenType: bigint;
      }
    ],
    "view"
  >;

  unsafeProcessBatch: TypedContractMethod<
    [entity: BytesLike, batch: BatchStruct],
    [boolean],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "DOMAIN_SEPARATOR"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "_accounts"
  ): TypedContractMethod<
    [arg0: BytesLike],
    [
      [bigint, string, bigint] & {
        cooperativeNonce: bigint;
        disputeHash: string;
        disputeTimeout: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "_activeDebts"
  ): TypedContractMethod<[arg0: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "_collaterals"
  ): TypedContractMethod<
    [arg0: BytesLike, arg1: BigNumberish],
    [[bigint, bigint] & { collateral: bigint; ondelta: bigint }],
    "view"
  >;
  getFunction(
    nameOrSignature: "_debtIndex"
  ): TypedContractMethod<
    [arg0: BytesLike, arg1: BigNumberish],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "_debts"
  ): TypedContractMethod<
    [arg0: BytesLike, arg1: BigNumberish, arg2: BigNumberish],
    [[string, bigint] & { creditor: string; amount: bigint }],
    "view"
  >;
  getFunction(
    nameOrSignature: "_reserves"
  ): TypedContractMethod<
    [arg0: BytesLike, arg1: BigNumberish],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "_tokens"
  ): TypedContractMethod<
    [arg0: BigNumberish],
    [
      [string, bigint, bigint] & {
        contractAddress: string;
        externalTokenId: bigint;
        tokenType: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "accountKey"
  ): TypedContractMethod<[e1: BytesLike, e2: BytesLike], [string], "view">;
  getFunction(
    nameOrSignature: "addEntityProvider"
  ): TypedContractMethod<[provider: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "admin"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "approvedEntityProviders"
  ): TypedContractMethod<[arg0: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "computeSettlementHash"
  ): TypedContractMethod<
    [
      leftEntity: BytesLike,
      rightEntity: BytesLike,
      diffs: SettlementDiffStruct[],
      forgiveDebtsInTokenIds: BigNumberish[],
      insuranceRegs: InsuranceRegistrationStruct[]
    ],
    [
      [string, bigint, bigint] & {
        hash: string;
        nonce: bigint;
        encodedMsgLength: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "defaultDisputeDelay"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "disputeFinalize"
  ): TypedContractMethod<
    [params: FinalDisputeProofStruct],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "disputeStart"
  ): TypedContractMethod<
    [params: InitialDisputeProofStruct],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "emergencyPause"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "enforceDebts"
  ): TypedContractMethod<
    [entity: BytesLike, tokenId: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "enforceDebtsLarge"
  ): TypedContractMethod<
    [entity: BytesLike, tokenId: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "entityDisputeDelays"
  ): TypedContractMethod<[arg0: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "entityNonces"
  ): TypedContractMethod<[arg0: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "entityProvider"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "entityProvidersList"
  ): TypedContractMethod<[arg0: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "externalTokenToReserve"
  ): TypedContractMethod<
    [params: ExternalTokenToReserveStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getApprovedProviders"
  ): TypedContractMethod<[], [string[]], "view">;
  getFunction(
    nameOrSignature: "getTokenMetadata"
  ): TypedContractMethod<
    [tokenId: BigNumberish],
    [
      [string, bigint, bigint] & {
        contractAddress: string;
        externalTokenId: bigint;
        tokenType: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getTokensLength"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "insuranceCursor"
  ): TypedContractMethod<[arg0: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "insuranceLines"
  ): TypedContractMethod<
    [arg0: BytesLike, arg1: BigNumberish],
    [
      [string, bigint, bigint, bigint] & {
        insurer: string;
        tokenId: bigint;
        remaining: bigint;
        expiresAt: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "mintToReserve"
  ): TypedContractMethod<
    [entity: BytesLike, tokenId: BigNumberish, amount: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "onERC1155BatchReceived"
  ): TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike,
      arg2: BigNumberish[],
      arg3: BigNumberish[],
      arg4: BytesLike
    ],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "onERC1155Received"
  ): TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike,
      id: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike
    ],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "packTokenReference"
  ): TypedContractMethod<
    [
      tokenType: BigNumberish,
      contractAddress: AddressLike,
      externalTokenId: BigNumberish
    ],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "processBatch"
  ): TypedContractMethod<
    [
      encodedBatch: BytesLike,
      entityProviderAddr: AddressLike,
      hankoData: BytesLike,
      nonce: BigNumberish
    ],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "removeEntityProvider"
  ): TypedContractMethod<[provider: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "reserveToReserve"
  ): TypedContractMethod<
    [
      fromEntity: BytesLike,
      toEntity: BytesLike,
      tokenId: BigNumberish,
      amount: BigNumberish
    ],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setDefaultDisputeDelay"
  ): TypedContractMethod<[delayBlocks: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setEmergencyPause"
  ): TypedContractMethod<[isPaused: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setEntityDisputeDelay"
  ): TypedContractMethod<
    [entity: BytesLike, delayBlocks: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "settle"
  ): TypedContractMethod<
    [
      leftEntity: BytesLike,
      rightEntity: BytesLike,
      diffs: SettlementDiffStruct[],
      forgiveDebtsInTokenIds: BigNumberish[],
      insuranceRegs: InsuranceRegistrationStruct[],
      sig: BytesLike
    ],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "tokenToId"
  ): TypedContractMethod<[arg0: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "unpackTokenReference"
  ): TypedContractMethod<
    [packed: BytesLike],
    [
      [string, bigint, bigint] & {
        contractAddress: string;
        externalTokenId: bigint;
        tokenType: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "unsafeProcessBatch"
  ): TypedContractMethod<
    [entity: BytesLike, batch: BatchStruct],
    [boolean],
    "nonpayable"
  >;

  getEvent(
    key: "AccountSettled"
  ): TypedContractEvent<
    AccountSettledEvent.InputTuple,
    AccountSettledEvent.OutputTuple,
    AccountSettledEvent.OutputObject
  >;
  getEvent(
    key: "CooperativeClose"
  ): TypedContractEvent<
    CooperativeCloseEvent.InputTuple,
    CooperativeCloseEvent.OutputTuple,
    CooperativeCloseEvent.OutputObject
  >;
  getEvent(
    key: "DebtCreated"
  ): TypedContractEvent<
    DebtCreatedEvent.InputTuple,
    DebtCreatedEvent.OutputTuple,
    DebtCreatedEvent.OutputObject
  >;
  getEvent(
    key: "DebtEnforced"
  ): TypedContractEvent<
    DebtEnforcedEvent.InputTuple,
    DebtEnforcedEvent.OutputTuple,
    DebtEnforcedEvent.OutputObject
  >;
  getEvent(
    key: "DebtForgiven"
  ): TypedContractEvent<
    DebtForgivenEvent.InputTuple,
    DebtForgivenEvent.OutputTuple,
    DebtForgivenEvent.OutputObject
  >;
  getEvent(
    key: "DebugSettleStart"
  ): TypedContractEvent<
    DebugSettleStartEvent.InputTuple,
    DebugSettleStartEvent.OutputTuple,
    DebugSettleStartEvent.OutputObject
  >;
  getEvent(
    key: "DisputeFinalized"
  ): TypedContractEvent<
    DisputeFinalizedEvent.InputTuple,
    DisputeFinalizedEvent.OutputTuple,
    DisputeFinalizedEvent.OutputObject
  >;
  getEvent(
    key: "DisputeStarted"
  ): TypedContractEvent<
    DisputeStartedEvent.InputTuple,
    DisputeStartedEvent.OutputTuple,
    DisputeStartedEvent.OutputObject
  >;
  getEvent(
    key: "EmergencyPauseToggled"
  ): TypedContractEvent<
    EmergencyPauseToggledEvent.InputTuple,
    EmergencyPauseToggledEvent.OutputTuple,
    EmergencyPauseToggledEvent.OutputObject
  >;
  getEvent(
    key: "EntityProviderAdded"
  ): TypedContractEvent<
    EntityProviderAddedEvent.InputTuple,
    EntityProviderAddedEvent.OutputTuple,
    EntityProviderAddedEvent.OutputObject
  >;
  getEvent(
    key: "EntityProviderRemoved"
  ): TypedContractEvent<
    EntityProviderRemovedEvent.InputTuple,
    EntityProviderRemovedEvent.OutputTuple,
    EntityProviderRemovedEvent.OutputObject
  >;
  getEvent(
    key: "HankoBatchProcessed"
  ): TypedContractEvent<
    HankoBatchProcessedEvent.InputTuple,
    HankoBatchProcessedEvent.OutputTuple,
    HankoBatchProcessedEvent.OutputObject
  >;
  getEvent(
    key: "InsuranceClaimed"
  ): TypedContractEvent<
    InsuranceClaimedEvent.InputTuple,
    InsuranceClaimedEvent.OutputTuple,
    InsuranceClaimedEvent.OutputObject
  >;
  getEvent(
    key: "InsuranceRegistered"
  ): TypedContractEvent<
    InsuranceRegisteredEvent.InputTuple,
    InsuranceRegisteredEvent.OutputTuple,
    InsuranceRegisteredEvent.OutputObject
  >;
  getEvent(
    key: "ReserveUpdated"
  ): TypedContractEvent<
    ReserveUpdatedEvent.InputTuple,
    ReserveUpdatedEvent.OutputTuple,
    ReserveUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "SecretRevealed"
  ): TypedContractEvent<
    SecretRevealedEvent.InputTuple,
    SecretRevealedEvent.OutputTuple,
    SecretRevealedEvent.OutputObject
  >;

  filters: {
    "AccountSettled(tuple[])": TypedContractEvent<
      AccountSettledEvent.InputTuple,
      AccountSettledEvent.OutputTuple,
      AccountSettledEvent.OutputObject
    >;
    AccountSettled: TypedContractEvent<
      AccountSettledEvent.InputTuple,
      AccountSettledEvent.OutputTuple,
      AccountSettledEvent.OutputObject
    >;

    "CooperativeClose(bytes32,bytes32,uint256)": TypedContractEvent<
      CooperativeCloseEvent.InputTuple,
      CooperativeCloseEvent.OutputTuple,
      CooperativeCloseEvent.OutputObject
    >;
    CooperativeClose: TypedContractEvent<
      CooperativeCloseEvent.InputTuple,
      CooperativeCloseEvent.OutputTuple,
      CooperativeCloseEvent.OutputObject
    >;

    "DebtCreated(bytes32,bytes32,uint256,uint256,uint256)": TypedContractEvent<
      DebtCreatedEvent.InputTuple,
      DebtCreatedEvent.OutputTuple,
      DebtCreatedEvent.OutputObject
    >;
    DebtCreated: TypedContractEvent<
      DebtCreatedEvent.InputTuple,
      DebtCreatedEvent.OutputTuple,
      DebtCreatedEvent.OutputObject
    >;

    "DebtEnforced(bytes32,bytes32,uint256,uint256,uint256,uint256)": TypedContractEvent<
      DebtEnforcedEvent.InputTuple,
      DebtEnforcedEvent.OutputTuple,
      DebtEnforcedEvent.OutputObject
    >;
    DebtEnforced: TypedContractEvent<
      DebtEnforcedEvent.InputTuple,
      DebtEnforcedEvent.OutputTuple,
      DebtEnforcedEvent.OutputObject
    >;

    "DebtForgiven(bytes32,bytes32,uint256,uint256,uint256)": TypedContractEvent<
      DebtForgivenEvent.InputTuple,
      DebtForgivenEvent.OutputTuple,
      DebtForgivenEvent.OutputObject
    >;
    DebtForgiven: TypedContractEvent<
      DebtForgivenEvent.InputTuple,
      DebtForgivenEvent.OutputTuple,
      DebtForgivenEvent.OutputObject
    >;

    "DebugSettleStart(bytes32,bytes32,uint256,address)": TypedContractEvent<
      DebugSettleStartEvent.InputTuple,
      DebugSettleStartEvent.OutputTuple,
      DebugSettleStartEvent.OutputObject
    >;
    DebugSettleStart: TypedContractEvent<
      DebugSettleStartEvent.InputTuple,
      DebugSettleStartEvent.OutputTuple,
      DebugSettleStartEvent.OutputObject
    >;

    "DisputeFinalized(bytes32,bytes32,uint256,bytes32,bytes32)": TypedContractEvent<
      DisputeFinalizedEvent.InputTuple,
      DisputeFinalizedEvent.OutputTuple,
      DisputeFinalizedEvent.OutputObject
    >;
    DisputeFinalized: TypedContractEvent<
      DisputeFinalizedEvent.InputTuple,
      DisputeFinalizedEvent.OutputTuple,
      DisputeFinalizedEvent.OutputObject
    >;

    "DisputeStarted(bytes32,bytes32,uint256,bytes32,bytes)": TypedContractEvent<
      DisputeStartedEvent.InputTuple,
      DisputeStartedEvent.OutputTuple,
      DisputeStartedEvent.OutputObject
    >;
    DisputeStarted: TypedContractEvent<
      DisputeStartedEvent.InputTuple,
      DisputeStartedEvent.OutputTuple,
      DisputeStartedEvent.OutputObject
    >;

    "EmergencyPauseToggled(bool)": TypedContractEvent<
      EmergencyPauseToggledEvent.InputTuple,
      EmergencyPauseToggledEvent.OutputTuple,
      EmergencyPauseToggledEvent.OutputObject
    >;
    EmergencyPauseToggled: TypedContractEvent<
      EmergencyPauseToggledEvent.InputTuple,
      EmergencyPauseToggledEvent.OutputTuple,
      EmergencyPauseToggledEvent.OutputObject
    >;

    "EntityProviderAdded(address)": TypedContractEvent<
      EntityProviderAddedEvent.InputTuple,
      EntityProviderAddedEvent.OutputTuple,
      EntityProviderAddedEvent.OutputObject
    >;
    EntityProviderAdded: TypedContractEvent<
      EntityProviderAddedEvent.InputTuple,
      EntityProviderAddedEvent.OutputTuple,
      EntityProviderAddedEvent.OutputObject
    >;

    "EntityProviderRemoved(address)": TypedContractEvent<
      EntityProviderRemovedEvent.InputTuple,
      EntityProviderRemovedEvent.OutputTuple,
      EntityProviderRemovedEvent.OutputObject
    >;
    EntityProviderRemoved: TypedContractEvent<
      EntityProviderRemovedEvent.InputTuple,
      EntityProviderRemovedEvent.OutputTuple,
      EntityProviderRemovedEvent.OutputObject
    >;

    "HankoBatchProcessed(bytes32,bytes32,uint256,bool)": TypedContractEvent<
      HankoBatchProcessedEvent.InputTuple,
      HankoBatchProcessedEvent.OutputTuple,
      HankoBatchProcessedEvent.OutputObject
    >;
    HankoBatchProcessed: TypedContractEvent<
      HankoBatchProcessedEvent.InputTuple,
      HankoBatchProcessedEvent.OutputTuple,
      HankoBatchProcessedEvent.OutputObject
    >;

    "InsuranceClaimed(bytes32,bytes32,bytes32,uint256,uint256)": TypedContractEvent<
      InsuranceClaimedEvent.InputTuple,
      InsuranceClaimedEvent.OutputTuple,
      InsuranceClaimedEvent.OutputObject
    >;
    InsuranceClaimed: TypedContractEvent<
      InsuranceClaimedEvent.InputTuple,
      InsuranceClaimedEvent.OutputTuple,
      InsuranceClaimedEvent.OutputObject
    >;

    "InsuranceRegistered(bytes32,bytes32,uint256,uint256,uint256)": TypedContractEvent<
      InsuranceRegisteredEvent.InputTuple,
      InsuranceRegisteredEvent.OutputTuple,
      InsuranceRegisteredEvent.OutputObject
    >;
    InsuranceRegistered: TypedContractEvent<
      InsuranceRegisteredEvent.InputTuple,
      InsuranceRegisteredEvent.OutputTuple,
      InsuranceRegisteredEvent.OutputObject
    >;

    "ReserveUpdated(bytes32,uint256,uint256)": TypedContractEvent<
      ReserveUpdatedEvent.InputTuple,
      ReserveUpdatedEvent.OutputTuple,
      ReserveUpdatedEvent.OutputObject
    >;
    ReserveUpdated: TypedContractEvent<
      ReserveUpdatedEvent.InputTuple,
      ReserveUpdatedEvent.OutputTuple,
      ReserveUpdatedEvent.OutputObject
    >;

    "SecretRevealed(bytes32,bytes32,bytes32)": TypedContractEvent<
      SecretRevealedEvent.InputTuple,
      SecretRevealedEvent.OutputTuple,
      SecretRevealedEvent.OutputObject
    >;
    SecretRevealed: TypedContractEvent<
      SecretRevealedEvent.InputTuple,
      SecretRevealedEvent.OutputTuple,
      SecretRevealedEvent.OutputObject
    >;
  };
}
