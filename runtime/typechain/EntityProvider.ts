/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "./common";

export declare namespace EntityProvider {
  export type EntityArticlesStruct = {
    controlDelay: BigNumberish;
    dividendDelay: BigNumberish;
    foundationDelay: BigNumberish;
    controlThreshold: BigNumberish;
  };

  export type EntityArticlesStructOutput = [
    controlDelay: bigint,
    dividendDelay: bigint,
    foundationDelay: bigint,
    controlThreshold: bigint
  ] & {
    controlDelay: bigint;
    dividendDelay: bigint;
    foundationDelay: bigint;
    controlThreshold: bigint;
  };
}

export interface EntityProviderInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "FOUNDATION_ENTITY"
      | "TOTAL_CONTROL_SUPPLY"
      | "TOTAL_DIVIDEND_SUPPLY"
      | "activateBoard"
      | "activeProposals"
      | "assignName"
      | "balanceOf"
      | "balanceOfBatch"
      | "batchVerifyHankoSignatures"
      | "cancelBoardProposal"
      | "entities"
      | "entityTransferTokens"
      | "foundationRegisterEntity"
      | "getEntityFromToken"
      | "getEntityInfo"
      | "getGovernanceInfo"
      | "getTokenIds"
      | "isApprovedForAll"
      | "nameQuota"
      | "nameToNumber"
      | "nextNumber"
      | "numberToName"
      | "proposeBoard"
      | "recoverEntity"
      | "registerNumberedEntitiesBatch"
      | "registerNumberedEntity"
      | "releaseControlShares"
      | "reservedNames"
      | "resolveEntityId"
      | "safeBatchTransferFrom"
      | "safeTransferFrom"
      | "setApprovalForAll"
      | "setNameQuota"
      | "setReservedName"
      | "supportsInterface"
      | "totalControlSupply"
      | "totalDividendSupply"
      | "transferName"
      | "uri"
      | "verifyHankoSignature"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "ApprovalForAll"
      | "BoardActivated"
      | "BoardProposed"
      | "ControlSharesReleased"
      | "DebugComputeBoard"
      | "DebugHankoDecode"
      | "DebugHankoEntry"
      | "DebugRecoverSigner"
      | "DebugValidateEntity"
      | "EntityRegistered"
      | "GovernanceEnabled"
      | "HankoClaimProcessed"
      | "HankoVerified"
      | "NameAssigned"
      | "NameTransferred"
      | "ProposalCancelled"
      | "TransferBatch"
      | "TransferSingle"
      | "URI"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "FOUNDATION_ENTITY",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "TOTAL_CONTROL_SUPPLY",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "TOTAL_DIVIDEND_SUPPLY",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "activateBoard",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "activeProposals",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "assignName",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOfBatch",
    values: [AddressLike[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchVerifyHankoSignatures",
    values: [BytesLike[], BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelBoardProposal",
    values: [BytesLike, BigNumberish, EntityProvider.EntityArticlesStruct]
  ): string;
  encodeFunctionData(functionFragment: "entities", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "entityTransferTokens",
    values: [
      BigNumberish,
      AddressLike,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "foundationRegisterEntity",
    values: [BytesLike, EntityProvider.EntityArticlesStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getEntityFromToken",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getEntityInfo",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getGovernanceInfo",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenIds",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "isApprovedForAll",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "nameQuota",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "nameToNumber",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "nextNumber",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "numberToName",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "proposeBoard",
    values: [
      BytesLike,
      BytesLike,
      BigNumberish,
      EntityProvider.EntityArticlesStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "recoverEntity",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "registerNumberedEntitiesBatch",
    values: [BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "registerNumberedEntity",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "releaseControlShares",
    values: [
      BigNumberish,
      AddressLike,
      BigNumberish,
      BigNumberish,
      string,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "reservedNames",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "resolveEntityId",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "safeBatchTransferFrom",
    values: [
      AddressLike,
      AddressLike,
      BigNumberish[],
      BigNumberish[],
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "safeTransferFrom",
    values: [AddressLike, AddressLike, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setApprovalForAll",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setNameQuota",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setReservedName",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "totalControlSupply",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "totalDividendSupply",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transferName",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "uri", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "verifyHankoSignature",
    values: [BytesLike, BytesLike]
  ): string;

  decodeFunctionResult(
    functionFragment: "FOUNDATION_ENTITY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "TOTAL_CONTROL_SUPPLY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "TOTAL_DIVIDEND_SUPPLY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "activateBoard",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "activeProposals",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "assignName", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "balanceOfBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchVerifyHankoSignatures",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelBoardProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "entities", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "entityTransferTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "foundationRegisterEntity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getEntityFromToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getEntityInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getGovernanceInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenIds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isApprovedForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "nameQuota", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "nameToNumber",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "nextNumber", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "numberToName",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposeBoard",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "recoverEntity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerNumberedEntitiesBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerNumberedEntity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "releaseControlShares",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "reservedNames",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "resolveEntityId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "safeBatchTransferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "safeTransferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setApprovalForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setNameQuota",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setReservedName",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalControlSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalDividendSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferName",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "uri", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "verifyHankoSignature",
    data: BytesLike
  ): Result;
}

export namespace ApprovalForAllEvent {
  export type InputTuple = [
    account: AddressLike,
    operator: AddressLike,
    approved: boolean
  ];
  export type OutputTuple = [
    account: string,
    operator: string,
    approved: boolean
  ];
  export interface OutputObject {
    account: string;
    operator: string;
    approved: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace BoardActivatedEvent {
  export type InputTuple = [entityId: BytesLike, newBoardHash: BytesLike];
  export type OutputTuple = [entityId: string, newBoardHash: string];
  export interface OutputObject {
    entityId: string;
    newBoardHash: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace BoardProposedEvent {
  export type InputTuple = [entityId: BytesLike, proposedBoardHash: BytesLike];
  export type OutputTuple = [entityId: string, proposedBoardHash: string];
  export interface OutputObject {
    entityId: string;
    proposedBoardHash: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ControlSharesReleasedEvent {
  export type InputTuple = [
    entityId: BytesLike,
    depository: AddressLike,
    controlAmount: BigNumberish,
    dividendAmount: BigNumberish,
    purpose: string
  ];
  export type OutputTuple = [
    entityId: string,
    depository: string,
    controlAmount: bigint,
    dividendAmount: bigint,
    purpose: string
  ];
  export interface OutputObject {
    entityId: string;
    depository: string;
    controlAmount: bigint;
    dividendAmount: bigint;
    purpose: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DebugComputeBoardEvent {
  export type InputTuple = [
    threshold: BigNumberish,
    entityId0: BytesLike,
    computedHash: BytesLike
  ];
  export type OutputTuple = [
    threshold: bigint,
    entityId0: string,
    computedHash: string
  ];
  export interface OutputObject {
    threshold: bigint;
    entityId0: string;
    computedHash: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DebugHankoDecodeEvent {
  export type InputTuple = [
    placeholders: BigNumberish,
    packedLen: BigNumberish,
    claims: BigNumberish
  ];
  export type OutputTuple = [
    placeholders: bigint,
    packedLen: bigint,
    claims: bigint
  ];
  export interface OutputObject {
    placeholders: bigint;
    packedLen: bigint;
    claims: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DebugHankoEntryEvent {
  export type InputTuple = [
    dataLen: BigNumberish,
    hash: BytesLike,
    gasLeft: BigNumberish
  ];
  export type OutputTuple = [dataLen: bigint, hash: string, gasLeft: bigint];
  export interface OutputObject {
    dataLen: bigint;
    hash: string;
    gasLeft: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DebugRecoverSignerEvent {
  export type InputTuple = [
    hash: BytesLike,
    recovered: AddressLike,
    sigLength: BigNumberish
  ];
  export type OutputTuple = [
    hash: string,
    recovered: string,
    sigLength: bigint
  ];
  export interface OutputObject {
    hash: string;
    recovered: string;
    sigLength: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DebugValidateEntityEvent {
  export type InputTuple = [
    entityId: BytesLike,
    computedHash: BytesLike,
    storedHash: BytesLike,
    isLazy: boolean
  ];
  export type OutputTuple = [
    entityId: string,
    computedHash: string,
    storedHash: string,
    isLazy: boolean
  ];
  export interface OutputObject {
    entityId: string;
    computedHash: string;
    storedHash: string;
    isLazy: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace EntityRegisteredEvent {
  export type InputTuple = [
    entityId: BytesLike,
    entityNumber: BigNumberish,
    boardHash: BytesLike
  ];
  export type OutputTuple = [
    entityId: string,
    entityNumber: bigint,
    boardHash: string
  ];
  export interface OutputObject {
    entityId: string;
    entityNumber: bigint;
    boardHash: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace GovernanceEnabledEvent {
  export type InputTuple = [
    entityId: BytesLike,
    controlTokenId: BigNumberish,
    dividendTokenId: BigNumberish
  ];
  export type OutputTuple = [
    entityId: string,
    controlTokenId: bigint,
    dividendTokenId: bigint
  ];
  export interface OutputObject {
    entityId: string;
    controlTokenId: bigint;
    dividendTokenId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace HankoClaimProcessedEvent {
  export type InputTuple = [
    entityId: BytesLike,
    success: boolean,
    votingPower: BigNumberish
  ];
  export type OutputTuple = [
    entityId: string,
    success: boolean,
    votingPower: bigint
  ];
  export interface OutputObject {
    entityId: string;
    success: boolean;
    votingPower: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace HankoVerifiedEvent {
  export type InputTuple = [entityId: BytesLike, hash: BytesLike];
  export type OutputTuple = [entityId: string, hash: string];
  export interface OutputObject {
    entityId: string;
    hash: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace NameAssignedEvent {
  export type InputTuple = [name: string, entityNumber: BigNumberish];
  export type OutputTuple = [name: string, entityNumber: bigint];
  export interface OutputObject {
    name: string;
    entityNumber: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace NameTransferredEvent {
  export type InputTuple = [
    name: string,
    fromNumber: BigNumberish,
    toNumber: BigNumberish
  ];
  export type OutputTuple = [
    name: string,
    fromNumber: bigint,
    toNumber: bigint
  ];
  export interface OutputObject {
    name: string;
    fromNumber: bigint;
    toNumber: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ProposalCancelledEvent {
  export type InputTuple = [entityId: BytesLike, cancelledBy: BigNumberish];
  export type OutputTuple = [entityId: string, cancelledBy: bigint];
  export interface OutputObject {
    entityId: string;
    cancelledBy: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferBatchEvent {
  export type InputTuple = [
    operator: AddressLike,
    from: AddressLike,
    to: AddressLike,
    ids: BigNumberish[],
    values: BigNumberish[]
  ];
  export type OutputTuple = [
    operator: string,
    from: string,
    to: string,
    ids: bigint[],
    values: bigint[]
  ];
  export interface OutputObject {
    operator: string;
    from: string;
    to: string;
    ids: bigint[];
    values: bigint[];
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferSingleEvent {
  export type InputTuple = [
    operator: AddressLike,
    from: AddressLike,
    to: AddressLike,
    id: BigNumberish,
    value: BigNumberish
  ];
  export type OutputTuple = [
    operator: string,
    from: string,
    to: string,
    id: bigint,
    value: bigint
  ];
  export interface OutputObject {
    operator: string;
    from: string;
    to: string;
    id: bigint;
    value: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace URIEvent {
  export type InputTuple = [value: string, id: BigNumberish];
  export type OutputTuple = [value: string, id: bigint];
  export interface OutputObject {
    value: string;
    id: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface EntityProvider extends BaseContract {
  connect(runner?: ContractRunner | null): EntityProvider;
  waitForDeployment(): Promise<this>;

  interface: EntityProviderInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  FOUNDATION_ENTITY: TypedContractMethod<[], [bigint], "view">;

  TOTAL_CONTROL_SUPPLY: TypedContractMethod<[], [bigint], "view">;

  TOTAL_DIVIDEND_SUPPLY: TypedContractMethod<[], [bigint], "view">;

  activateBoard: TypedContractMethod<
    [entityId: BytesLike],
    [void],
    "nonpayable"
  >;

  activeProposals: TypedContractMethod<
    [arg0: BytesLike],
    [
      [string, bigint, bigint, bigint, boolean] & {
        proposedBoardHash: string;
        proposerType: bigint;
        proposeBlock: bigint;
        activateBlock: bigint;
        active: boolean;
      }
    ],
    "view"
  >;

  assignName: TypedContractMethod<
    [name: string, entityNumber: BigNumberish],
    [void],
    "nonpayable"
  >;

  balanceOf: TypedContractMethod<
    [account: AddressLike, id: BigNumberish],
    [bigint],
    "view"
  >;

  balanceOfBatch: TypedContractMethod<
    [accounts: AddressLike[], ids: BigNumberish[]],
    [bigint[]],
    "view"
  >;

  batchVerifyHankoSignatures: TypedContractMethod<
    [hankoDataArray: BytesLike[], hashes: BytesLike[]],
    [[string[], boolean[]] & { entityIds: string[]; results: boolean[] }],
    "nonpayable"
  >;

  cancelBoardProposal: TypedContractMethod<
    [
      entityId: BytesLike,
      proposerType: BigNumberish,
      articles: EntityProvider.EntityArticlesStruct
    ],
    [void],
    "nonpayable"
  >;

  entities: TypedContractMethod<
    [arg0: BytesLike],
    [
      [string, string, bigint, bigint, bigint, string] & {
        currentBoardHash: string;
        proposedBoardHash: string;
        activateAtBlock: bigint;
        registrationBlock: bigint;
        proposerType: bigint;
        articlesHash: string;
      }
    ],
    "view"
  >;

  entityTransferTokens: TypedContractMethod<
    [
      entityNumber: BigNumberish,
      to: AddressLike,
      tokenId: BigNumberish,
      amount: BigNumberish,
      encodedBoard: BytesLike,
      encodedSignature: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  foundationRegisterEntity: TypedContractMethod<
    [boardHash: BytesLike, articles: EntityProvider.EntityArticlesStruct],
    [bigint],
    "nonpayable"
  >;

  getEntityFromToken: TypedContractMethod<
    [tokenId: BigNumberish],
    [bigint],
    "view"
  >;

  getEntityInfo: TypedContractMethod<
    [entityId: BytesLike],
    [
      [boolean, string, string, bigint, string] & {
        exists: boolean;
        currentBoardHash: string;
        proposedBoardHash: string;
        registrationBlock: bigint;
        name: string;
      }
    ],
    "view"
  >;

  getGovernanceInfo: TypedContractMethod<
    [entityNumber: BigNumberish],
    [
      [bigint, bigint, bigint, bigint, boolean, string] & {
        controlTokenId: bigint;
        dividendTokenId: bigint;
        controlSupply: bigint;
        dividendSupply: bigint;
        hasActiveProposal: boolean;
        articlesHash: string;
      }
    ],
    "view"
  >;

  getTokenIds: TypedContractMethod<
    [entityNumber: BigNumberish],
    [[bigint, bigint] & { controlTokenId: bigint; dividendTokenId: bigint }],
    "view"
  >;

  isApprovedForAll: TypedContractMethod<
    [account: AddressLike, operator: AddressLike],
    [boolean],
    "view"
  >;

  nameQuota: TypedContractMethod<[arg0: AddressLike], [bigint], "view">;

  nameToNumber: TypedContractMethod<[arg0: string], [bigint], "view">;

  nextNumber: TypedContractMethod<[], [bigint], "view">;

  numberToName: TypedContractMethod<[arg0: BigNumberish], [string], "view">;

  proposeBoard: TypedContractMethod<
    [
      entityId: BytesLike,
      newBoardHash: BytesLike,
      proposerType: BigNumberish,
      articles: EntityProvider.EntityArticlesStruct
    ],
    [void],
    "nonpayable"
  >;

  recoverEntity: TypedContractMethod<
    [encodedBoard: BytesLike, encodedSignature: BytesLike, hash: BytesLike],
    [bigint],
    "view"
  >;

  registerNumberedEntitiesBatch: TypedContractMethod<
    [boardHashes: BytesLike[]],
    [bigint[]],
    "nonpayable"
  >;

  registerNumberedEntity: TypedContractMethod<
    [boardHash: BytesLike],
    [bigint],
    "nonpayable"
  >;

  releaseControlShares: TypedContractMethod<
    [
      entityNumber: BigNumberish,
      depository: AddressLike,
      controlAmount: BigNumberish,
      dividendAmount: BigNumberish,
      purpose: string,
      encodedBoard: BytesLike,
      encodedSignature: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  reservedNames: TypedContractMethod<[arg0: string], [boolean], "view">;

  resolveEntityId: TypedContractMethod<[identifier: string], [string], "view">;

  safeBatchTransferFrom: TypedContractMethod<
    [
      from: AddressLike,
      to: AddressLike,
      ids: BigNumberish[],
      values: BigNumberish[],
      data: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  safeTransferFrom: TypedContractMethod<
    [
      from: AddressLike,
      to: AddressLike,
      id: BigNumberish,
      value: BigNumberish,
      data: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  setApprovalForAll: TypedContractMethod<
    [operator: AddressLike, approved: boolean],
    [void],
    "nonpayable"
  >;

  setNameQuota: TypedContractMethod<
    [user: AddressLike, quota: BigNumberish],
    [void],
    "nonpayable"
  >;

  setReservedName: TypedContractMethod<
    [name: string, reserved: boolean],
    [void],
    "nonpayable"
  >;

  supportsInterface: TypedContractMethod<
    [interfaceId: BytesLike],
    [boolean],
    "view"
  >;

  totalControlSupply: TypedContractMethod<[arg0: BytesLike], [bigint], "view">;

  totalDividendSupply: TypedContractMethod<[arg0: BytesLike], [bigint], "view">;

  transferName: TypedContractMethod<
    [name: string, newEntityNumber: BigNumberish],
    [void],
    "nonpayable"
  >;

  uri: TypedContractMethod<[arg0: BigNumberish], [string], "view">;

  verifyHankoSignature: TypedContractMethod<
    [hankoData: BytesLike, hash: BytesLike],
    [[string, boolean] & { entityId: string; success: boolean }],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "FOUNDATION_ENTITY"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "TOTAL_CONTROL_SUPPLY"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "TOTAL_DIVIDEND_SUPPLY"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "activateBoard"
  ): TypedContractMethod<[entityId: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "activeProposals"
  ): TypedContractMethod<
    [arg0: BytesLike],
    [
      [string, bigint, bigint, bigint, boolean] & {
        proposedBoardHash: string;
        proposerType: bigint;
        proposeBlock: bigint;
        activateBlock: bigint;
        active: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "assignName"
  ): TypedContractMethod<
    [name: string, entityNumber: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "balanceOf"
  ): TypedContractMethod<
    [account: AddressLike, id: BigNumberish],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "balanceOfBatch"
  ): TypedContractMethod<
    [accounts: AddressLike[], ids: BigNumberish[]],
    [bigint[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "batchVerifyHankoSignatures"
  ): TypedContractMethod<
    [hankoDataArray: BytesLike[], hashes: BytesLike[]],
    [[string[], boolean[]] & { entityIds: string[]; results: boolean[] }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "cancelBoardProposal"
  ): TypedContractMethod<
    [
      entityId: BytesLike,
      proposerType: BigNumberish,
      articles: EntityProvider.EntityArticlesStruct
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "entities"
  ): TypedContractMethod<
    [arg0: BytesLike],
    [
      [string, string, bigint, bigint, bigint, string] & {
        currentBoardHash: string;
        proposedBoardHash: string;
        activateAtBlock: bigint;
        registrationBlock: bigint;
        proposerType: bigint;
        articlesHash: string;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "entityTransferTokens"
  ): TypedContractMethod<
    [
      entityNumber: BigNumberish,
      to: AddressLike,
      tokenId: BigNumberish,
      amount: BigNumberish,
      encodedBoard: BytesLike,
      encodedSignature: BytesLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "foundationRegisterEntity"
  ): TypedContractMethod<
    [boardHash: BytesLike, articles: EntityProvider.EntityArticlesStruct],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getEntityFromToken"
  ): TypedContractMethod<[tokenId: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "getEntityInfo"
  ): TypedContractMethod<
    [entityId: BytesLike],
    [
      [boolean, string, string, bigint, string] & {
        exists: boolean;
        currentBoardHash: string;
        proposedBoardHash: string;
        registrationBlock: bigint;
        name: string;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getGovernanceInfo"
  ): TypedContractMethod<
    [entityNumber: BigNumberish],
    [
      [bigint, bigint, bigint, bigint, boolean, string] & {
        controlTokenId: bigint;
        dividendTokenId: bigint;
        controlSupply: bigint;
        dividendSupply: bigint;
        hasActiveProposal: boolean;
        articlesHash: string;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getTokenIds"
  ): TypedContractMethod<
    [entityNumber: BigNumberish],
    [[bigint, bigint] & { controlTokenId: bigint; dividendTokenId: bigint }],
    "view"
  >;
  getFunction(
    nameOrSignature: "isApprovedForAll"
  ): TypedContractMethod<
    [account: AddressLike, operator: AddressLike],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "nameQuota"
  ): TypedContractMethod<[arg0: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "nameToNumber"
  ): TypedContractMethod<[arg0: string], [bigint], "view">;
  getFunction(
    nameOrSignature: "nextNumber"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "numberToName"
  ): TypedContractMethod<[arg0: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "proposeBoard"
  ): TypedContractMethod<
    [
      entityId: BytesLike,
      newBoardHash: BytesLike,
      proposerType: BigNumberish,
      articles: EntityProvider.EntityArticlesStruct
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "recoverEntity"
  ): TypedContractMethod<
    [encodedBoard: BytesLike, encodedSignature: BytesLike, hash: BytesLike],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "registerNumberedEntitiesBatch"
  ): TypedContractMethod<[boardHashes: BytesLike[]], [bigint[]], "nonpayable">;
  getFunction(
    nameOrSignature: "registerNumberedEntity"
  ): TypedContractMethod<[boardHash: BytesLike], [bigint], "nonpayable">;
  getFunction(
    nameOrSignature: "releaseControlShares"
  ): TypedContractMethod<
    [
      entityNumber: BigNumberish,
      depository: AddressLike,
      controlAmount: BigNumberish,
      dividendAmount: BigNumberish,
      purpose: string,
      encodedBoard: BytesLike,
      encodedSignature: BytesLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "reservedNames"
  ): TypedContractMethod<[arg0: string], [boolean], "view">;
  getFunction(
    nameOrSignature: "resolveEntityId"
  ): TypedContractMethod<[identifier: string], [string], "view">;
  getFunction(
    nameOrSignature: "safeBatchTransferFrom"
  ): TypedContractMethod<
    [
      from: AddressLike,
      to: AddressLike,
      ids: BigNumberish[],
      values: BigNumberish[],
      data: BytesLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "safeTransferFrom"
  ): TypedContractMethod<
    [
      from: AddressLike,
      to: AddressLike,
      id: BigNumberish,
      value: BigNumberish,
      data: BytesLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setApprovalForAll"
  ): TypedContractMethod<
    [operator: AddressLike, approved: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setNameQuota"
  ): TypedContractMethod<
    [user: AddressLike, quota: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setReservedName"
  ): TypedContractMethod<
    [name: string, reserved: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "supportsInterface"
  ): TypedContractMethod<[interfaceId: BytesLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "totalControlSupply"
  ): TypedContractMethod<[arg0: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "totalDividendSupply"
  ): TypedContractMethod<[arg0: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "transferName"
  ): TypedContractMethod<
    [name: string, newEntityNumber: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "uri"
  ): TypedContractMethod<[arg0: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "verifyHankoSignature"
  ): TypedContractMethod<
    [hankoData: BytesLike, hash: BytesLike],
    [[string, boolean] & { entityId: string; success: boolean }],
    "nonpayable"
  >;

  getEvent(
    key: "ApprovalForAll"
  ): TypedContractEvent<
    ApprovalForAllEvent.InputTuple,
    ApprovalForAllEvent.OutputTuple,
    ApprovalForAllEvent.OutputObject
  >;
  getEvent(
    key: "BoardActivated"
  ): TypedContractEvent<
    BoardActivatedEvent.InputTuple,
    BoardActivatedEvent.OutputTuple,
    BoardActivatedEvent.OutputObject
  >;
  getEvent(
    key: "BoardProposed"
  ): TypedContractEvent<
    BoardProposedEvent.InputTuple,
    BoardProposedEvent.OutputTuple,
    BoardProposedEvent.OutputObject
  >;
  getEvent(
    key: "ControlSharesReleased"
  ): TypedContractEvent<
    ControlSharesReleasedEvent.InputTuple,
    ControlSharesReleasedEvent.OutputTuple,
    ControlSharesReleasedEvent.OutputObject
  >;
  getEvent(
    key: "DebugComputeBoard"
  ): TypedContractEvent<
    DebugComputeBoardEvent.InputTuple,
    DebugComputeBoardEvent.OutputTuple,
    DebugComputeBoardEvent.OutputObject
  >;
  getEvent(
    key: "DebugHankoDecode"
  ): TypedContractEvent<
    DebugHankoDecodeEvent.InputTuple,
    DebugHankoDecodeEvent.OutputTuple,
    DebugHankoDecodeEvent.OutputObject
  >;
  getEvent(
    key: "DebugHankoEntry"
  ): TypedContractEvent<
    DebugHankoEntryEvent.InputTuple,
    DebugHankoEntryEvent.OutputTuple,
    DebugHankoEntryEvent.OutputObject
  >;
  getEvent(
    key: "DebugRecoverSigner"
  ): TypedContractEvent<
    DebugRecoverSignerEvent.InputTuple,
    DebugRecoverSignerEvent.OutputTuple,
    DebugRecoverSignerEvent.OutputObject
  >;
  getEvent(
    key: "DebugValidateEntity"
  ): TypedContractEvent<
    DebugValidateEntityEvent.InputTuple,
    DebugValidateEntityEvent.OutputTuple,
    DebugValidateEntityEvent.OutputObject
  >;
  getEvent(
    key: "EntityRegistered"
  ): TypedContractEvent<
    EntityRegisteredEvent.InputTuple,
    EntityRegisteredEvent.OutputTuple,
    EntityRegisteredEvent.OutputObject
  >;
  getEvent(
    key: "GovernanceEnabled"
  ): TypedContractEvent<
    GovernanceEnabledEvent.InputTuple,
    GovernanceEnabledEvent.OutputTuple,
    GovernanceEnabledEvent.OutputObject
  >;
  getEvent(
    key: "HankoClaimProcessed"
  ): TypedContractEvent<
    HankoClaimProcessedEvent.InputTuple,
    HankoClaimProcessedEvent.OutputTuple,
    HankoClaimProcessedEvent.OutputObject
  >;
  getEvent(
    key: "HankoVerified"
  ): TypedContractEvent<
    HankoVerifiedEvent.InputTuple,
    HankoVerifiedEvent.OutputTuple,
    HankoVerifiedEvent.OutputObject
  >;
  getEvent(
    key: "NameAssigned"
  ): TypedContractEvent<
    NameAssignedEvent.InputTuple,
    NameAssignedEvent.OutputTuple,
    NameAssignedEvent.OutputObject
  >;
  getEvent(
    key: "NameTransferred"
  ): TypedContractEvent<
    NameTransferredEvent.InputTuple,
    NameTransferredEvent.OutputTuple,
    NameTransferredEvent.OutputObject
  >;
  getEvent(
    key: "ProposalCancelled"
  ): TypedContractEvent<
    ProposalCancelledEvent.InputTuple,
    ProposalCancelledEvent.OutputTuple,
    ProposalCancelledEvent.OutputObject
  >;
  getEvent(
    key: "TransferBatch"
  ): TypedContractEvent<
    TransferBatchEvent.InputTuple,
    TransferBatchEvent.OutputTuple,
    TransferBatchEvent.OutputObject
  >;
  getEvent(
    key: "TransferSingle"
  ): TypedContractEvent<
    TransferSingleEvent.InputTuple,
    TransferSingleEvent.OutputTuple,
    TransferSingleEvent.OutputObject
  >;
  getEvent(
    key: "URI"
  ): TypedContractEvent<
    URIEvent.InputTuple,
    URIEvent.OutputTuple,
    URIEvent.OutputObject
  >;

  filters: {
    "ApprovalForAll(address,address,bool)": TypedContractEvent<
      ApprovalForAllEvent.InputTuple,
      ApprovalForAllEvent.OutputTuple,
      ApprovalForAllEvent.OutputObject
    >;
    ApprovalForAll: TypedContractEvent<
      ApprovalForAllEvent.InputTuple,
      ApprovalForAllEvent.OutputTuple,
      ApprovalForAllEvent.OutputObject
    >;

    "BoardActivated(bytes32,bytes32)": TypedContractEvent<
      BoardActivatedEvent.InputTuple,
      BoardActivatedEvent.OutputTuple,
      BoardActivatedEvent.OutputObject
    >;
    BoardActivated: TypedContractEvent<
      BoardActivatedEvent.InputTuple,
      BoardActivatedEvent.OutputTuple,
      BoardActivatedEvent.OutputObject
    >;

    "BoardProposed(bytes32,bytes32)": TypedContractEvent<
      BoardProposedEvent.InputTuple,
      BoardProposedEvent.OutputTuple,
      BoardProposedEvent.OutputObject
    >;
    BoardProposed: TypedContractEvent<
      BoardProposedEvent.InputTuple,
      BoardProposedEvent.OutputTuple,
      BoardProposedEvent.OutputObject
    >;

    "ControlSharesReleased(bytes32,address,uint256,uint256,string)": TypedContractEvent<
      ControlSharesReleasedEvent.InputTuple,
      ControlSharesReleasedEvent.OutputTuple,
      ControlSharesReleasedEvent.OutputObject
    >;
    ControlSharesReleased: TypedContractEvent<
      ControlSharesReleasedEvent.InputTuple,
      ControlSharesReleasedEvent.OutputTuple,
      ControlSharesReleasedEvent.OutputObject
    >;

    "DebugComputeBoard(uint256,bytes32,bytes32)": TypedContractEvent<
      DebugComputeBoardEvent.InputTuple,
      DebugComputeBoardEvent.OutputTuple,
      DebugComputeBoardEvent.OutputObject
    >;
    DebugComputeBoard: TypedContractEvent<
      DebugComputeBoardEvent.InputTuple,
      DebugComputeBoardEvent.OutputTuple,
      DebugComputeBoardEvent.OutputObject
    >;

    "DebugHankoDecode(uint256,uint256,uint256)": TypedContractEvent<
      DebugHankoDecodeEvent.InputTuple,
      DebugHankoDecodeEvent.OutputTuple,
      DebugHankoDecodeEvent.OutputObject
    >;
    DebugHankoDecode: TypedContractEvent<
      DebugHankoDecodeEvent.InputTuple,
      DebugHankoDecodeEvent.OutputTuple,
      DebugHankoDecodeEvent.OutputObject
    >;

    "DebugHankoEntry(uint256,bytes32,uint256)": TypedContractEvent<
      DebugHankoEntryEvent.InputTuple,
      DebugHankoEntryEvent.OutputTuple,
      DebugHankoEntryEvent.OutputObject
    >;
    DebugHankoEntry: TypedContractEvent<
      DebugHankoEntryEvent.InputTuple,
      DebugHankoEntryEvent.OutputTuple,
      DebugHankoEntryEvent.OutputObject
    >;

    "DebugRecoverSigner(bytes32,address,uint256)": TypedContractEvent<
      DebugRecoverSignerEvent.InputTuple,
      DebugRecoverSignerEvent.OutputTuple,
      DebugRecoverSignerEvent.OutputObject
    >;
    DebugRecoverSigner: TypedContractEvent<
      DebugRecoverSignerEvent.InputTuple,
      DebugRecoverSignerEvent.OutputTuple,
      DebugRecoverSignerEvent.OutputObject
    >;

    "DebugValidateEntity(bytes32,bytes32,bytes32,bool)": TypedContractEvent<
      DebugValidateEntityEvent.InputTuple,
      DebugValidateEntityEvent.OutputTuple,
      DebugValidateEntityEvent.OutputObject
    >;
    DebugValidateEntity: TypedContractEvent<
      DebugValidateEntityEvent.InputTuple,
      DebugValidateEntityEvent.OutputTuple,
      DebugValidateEntityEvent.OutputObject
    >;

    "EntityRegistered(bytes32,uint256,bytes32)": TypedContractEvent<
      EntityRegisteredEvent.InputTuple,
      EntityRegisteredEvent.OutputTuple,
      EntityRegisteredEvent.OutputObject
    >;
    EntityRegistered: TypedContractEvent<
      EntityRegisteredEvent.InputTuple,
      EntityRegisteredEvent.OutputTuple,
      EntityRegisteredEvent.OutputObject
    >;

    "GovernanceEnabled(bytes32,uint256,uint256)": TypedContractEvent<
      GovernanceEnabledEvent.InputTuple,
      GovernanceEnabledEvent.OutputTuple,
      GovernanceEnabledEvent.OutputObject
    >;
    GovernanceEnabled: TypedContractEvent<
      GovernanceEnabledEvent.InputTuple,
      GovernanceEnabledEvent.OutputTuple,
      GovernanceEnabledEvent.OutputObject
    >;

    "HankoClaimProcessed(bytes32,bool,uint256)": TypedContractEvent<
      HankoClaimProcessedEvent.InputTuple,
      HankoClaimProcessedEvent.OutputTuple,
      HankoClaimProcessedEvent.OutputObject
    >;
    HankoClaimProcessed: TypedContractEvent<
      HankoClaimProcessedEvent.InputTuple,
      HankoClaimProcessedEvent.OutputTuple,
      HankoClaimProcessedEvent.OutputObject
    >;

    "HankoVerified(bytes32,bytes32)": TypedContractEvent<
      HankoVerifiedEvent.InputTuple,
      HankoVerifiedEvent.OutputTuple,
      HankoVerifiedEvent.OutputObject
    >;
    HankoVerified: TypedContractEvent<
      HankoVerifiedEvent.InputTuple,
      HankoVerifiedEvent.OutputTuple,
      HankoVerifiedEvent.OutputObject
    >;

    "NameAssigned(string,uint256)": TypedContractEvent<
      NameAssignedEvent.InputTuple,
      NameAssignedEvent.OutputTuple,
      NameAssignedEvent.OutputObject
    >;
    NameAssigned: TypedContractEvent<
      NameAssignedEvent.InputTuple,
      NameAssignedEvent.OutputTuple,
      NameAssignedEvent.OutputObject
    >;

    "NameTransferred(string,uint256,uint256)": TypedContractEvent<
      NameTransferredEvent.InputTuple,
      NameTransferredEvent.OutputTuple,
      NameTransferredEvent.OutputObject
    >;
    NameTransferred: TypedContractEvent<
      NameTransferredEvent.InputTuple,
      NameTransferredEvent.OutputTuple,
      NameTransferredEvent.OutputObject
    >;

    "ProposalCancelled(bytes32,uint8)": TypedContractEvent<
      ProposalCancelledEvent.InputTuple,
      ProposalCancelledEvent.OutputTuple,
      ProposalCancelledEvent.OutputObject
    >;
    ProposalCancelled: TypedContractEvent<
      ProposalCancelledEvent.InputTuple,
      ProposalCancelledEvent.OutputTuple,
      ProposalCancelledEvent.OutputObject
    >;

    "TransferBatch(address,address,address,uint256[],uint256[])": TypedContractEvent<
      TransferBatchEvent.InputTuple,
      TransferBatchEvent.OutputTuple,
      TransferBatchEvent.OutputObject
    >;
    TransferBatch: TypedContractEvent<
      TransferBatchEvent.InputTuple,
      TransferBatchEvent.OutputTuple,
      TransferBatchEvent.OutputObject
    >;

    "TransferSingle(address,address,address,uint256,uint256)": TypedContractEvent<
      TransferSingleEvent.InputTuple,
      TransferSingleEvent.OutputTuple,
      TransferSingleEvent.OutputObject
    >;
    TransferSingle: TypedContractEvent<
      TransferSingleEvent.InputTuple,
      TransferSingleEvent.OutputTuple,
      TransferSingleEvent.OutputObject
    >;

    "URI(string,uint256)": TypedContractEvent<
      URIEvent.InputTuple,
      URIEvent.OutputTuple,
      URIEvent.OutputObject
    >;
    URI: TypedContractEvent<
      URIEvent.InputTuple,
      URIEvent.OutputTuple,
      URIEvent.OutputObject
    >;
  };
}
