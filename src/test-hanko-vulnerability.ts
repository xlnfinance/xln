#!/usr/bin/env bun
/**
 * Test Hanko "ASSUME YES" Vulnerability
 * Demonstrates how entities can mutually validate with zero EOA signatures
 */

import { ethers } from 'ethers';
import { recoverHankoEntities } from './hanko-real';
import type { HankoBytes } from './types';

async function testMutualValidation() {
  console.log('🔍 Testing Hanko Mutual Validation Vulnerability\n');

  // Create entity IDs (32-byte identifiers)
  const entityA = Buffer.from('a'.repeat(64), 'hex');
  const entityB = Buffer.from('b'.repeat(64), 'hex');

  console.log('📝 Setting up circular delegation:');
  console.log(`  EntityA (${ethers.hexlify(entityA).slice(0,10)}...) delegates to EntityB`);
  console.log(`  EntityB (${ethers.hexlify(entityB).slice(0,10)}...) delegates to EntityA`);

  // Build Hanko with mutual validation
  const hanko: HankoBytes = {
    placeholders: [], // No failed entities
    packedSignatures: Buffer.alloc(0), // ZERO EOA signatures!
    claims: [
      {
        entityId: entityA,
        entityIndexes: [1], // Points to claim 1 (EntityB)
        weights: [100],
        threshold: 100,
      },
      {
        entityId: entityB,
        entityIndexes: [0], // Points to claim 0 (EntityA)
        weights: [100],
        threshold: 100,
      },
    ],
  };

  console.log('\n🚨 VULNERABILITY: Zero EOA signatures required!');
  console.log(`  Packed signatures length: ${hanko.packedSignatures.length} bytes`);
  console.log(`  Number of claims: ${hanko.claims.length}`);

  // Test recovery with flashloan governance
  console.log('\n🔥 Testing flashloan governance recovery:');
  const testHash = Buffer.from('test'.repeat(8), 'hex');
  const result = await recoverHankoEntities(hanko, testHash);

  console.log('\n📊 Results:');
  console.log(`  ✅ Validated entities: ${result.yesEntities.length}`);
  for (const entity of result.yesEntities) {
    console.log(`    - ${ethers.hexlify(entity).slice(0,10)}...`);
  }
  console.log(`  ❌ Failed entities: ${result.noEntities.length}`);

  if (result.yesEntities.length === 2) {
    console.log('\n🎯 VULNERABILITY CONFIRMED!');
    console.log('Both entities validated each other with ZERO real signatures.');
    console.log('This is intentional "flashloan governance" - not a bug but a feature.');
    console.log('\nWhy this exists:');
    console.log('1. Enables sophisticated delegation chains');
    console.log('2. Gas efficient (no complex validation)');
    console.log('3. UI can enforce "at least 1 EOA" policy');
    console.log('4. Real entities will include EOAs for control');
  } else {
    console.log('\n❌ Vulnerability test failed - entities did not validate');
  }
}

async function testTriangleValidation() {
  console.log('\n\n🔺 Testing Triangle Validation (3-way circular)');

  const entityA = Buffer.from('a'.repeat(64), 'hex');
  const entityB = Buffer.from('b'.repeat(64), 'hex');
  const entityC = Buffer.from('c'.repeat(64), 'hex');

  console.log('📝 Setting up triangle:');
  console.log('  A → B → C → A');

  const hanko: HankoBytes = {
    placeholders: [],
    packedSignatures: Buffer.alloc(0),
    claims: [
      {
        entityId: entityA,
        entityIndexes: [1], // A needs B
        weights: [100],
        threshold: 100,
      },
      {
        entityId: entityB,
        entityIndexes: [2], // B needs C
        weights: [100],
        threshold: 100,
      },
      {
        entityId: entityC,
        entityIndexes: [0], // C needs A
        weights: [100],
        threshold: 100,
      },
    ],
  };

  const testHash = Buffer.from('test'.repeat(8), 'hex');
  const result = await recoverHankoEntities(hanko, testHash);

  console.log('\n📊 Triangle Results:');
  console.log(`  Validated: ${result.yesEntities.length}/3 entities`);

  if (result.yesEntities.length === 3) {
    console.log('  🎯 All 3 entities in triangle validated!');
    console.log('  No real signatures needed for entire governance ring.');
  }
}

// Run tests
testMutualValidation()
  .then(() => testTriangleValidation())
  .catch(console.error);