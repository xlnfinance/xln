# Cursor Rules for XLN AI Bot

## Project Overview
This is a Telegram bot that uses AI models via OpenRouter API to answer questions and manage battle sessions where participants critique XLN project.

## Code Style
- Use Python 3.10+ type hints
- Follow PEP 8 style guide
- Use async/await for all I/O operations
- Keep functions focused and single-purpose
- Use descriptive variable names
- Add docstrings for all functions and classes

## Project Structure
- `main.py` - Main bot logic, message handlers, and AI integration
- `db/database.py` - SQLite database operations
- `db/__init__.py` - Database module exports
- `context/llms.txt` - XLN project context documentation

## Key Patterns

### Database Operations
- All database functions should be in `db/database.py`
- Use connection-per-operation pattern
- Always handle exceptions and log errors
- Use parameterized queries to prevent SQL injection

### Message Handling
- Check `TARGET_CHAT_ID` before processing messages
- Save all messages to database (except error messages)
- Use `parse_mode='Markdown'` for formatted messages
- Split long messages (>4000 chars) using `split_long_message()`

### Battle Mode Logic
- Battle mode is determined by checking database for `start_battle`/`stop_battle` messages
- Use `is_battle_mode_active()` to check battle status
- In battle mode, get all messages since last `start_battle`
- In normal mode, get last 100 messages
- Battle commands should validate state before execution

### AI Integration
- Use `ask_openrouter()` for single model queries
- Use `ask_quorum()` for quorum mode (multiple models + Claude synthesis)
- All AI calls should include battle_mode context
- Scores in battle mode are 0-1000 range
- Prompts should be concise to avoid message length limits

### Error Handling
- Log all errors with `logger.error()` and `exc_info=True`
- Return user-friendly error messages
- Don't save error messages to database
- Handle API errors gracefully

## Specific Rules

### Battle Mode
- `start_battle` must check if battle is already active
- `stop_battle` must check if battle is active
- Error commands don't save to database
- Battle summary must parse scores and format scoreboard
- Battle summary must be split if too long

### Message Formatting
- Battle messages use Markdown formatting
- Status messages use emojis (‚è≥ waiting, ‚úÖ done, ‚ùå error)
- Scoreboard shows top 3 with medals (ü•áü•àü•â)
- Long messages must be split before sending

### Database Schema
- Table: `messages` with columns: id, chatid, datetime, userid, username, message
- Use ISO format for datetime strings
- Order by id ASC for chronological order

### Constants
- `TRIGGER` = "q1 " for regular queries
- `QUORUM_MODELS` = list of (model_id, model_name) tuples
- `FINAL_MODEL` = Claude model for synthesis
- `TARGET_CHAT_ID` = chat ID to listen to

## Code Quality
- Avoid global variables (except battle_start_time which was removed)
- Use type hints for function parameters and return values
- Keep functions under 50 lines when possible
- Use meaningful variable names in Russian context (battle_mode, summary, scores)
- Extract repeated code into helper functions

## Testing Considerations
- Test battle mode state transitions
- Test message splitting for long content
- Test score parsing from various formats
- Test database query edge cases
- Test error handling for API failures

## Performance
- Use async operations for all I/O
- Parallelize model queries with `asyncio.gather()`
- Limit context history to prevent token limits
- Cache XLN context file reading if needed

## Security
- Never commit `.env` file with tokens
- Use parameterized SQL queries
- Validate user input before processing
- Check chat ID before processing messages

## Documentation
- Update docstrings when changing function behavior
- Document battle mode logic clearly
- Comment complex regex patterns
- Explain score parsing logic

